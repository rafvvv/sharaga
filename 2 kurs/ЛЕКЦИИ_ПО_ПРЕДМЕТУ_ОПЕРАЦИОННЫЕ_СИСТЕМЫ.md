
# 1. Структура вычислительной системы.

Пользователь -> Прикладные программы -> Системные программы (Операционная система) -> Техническое обеспечение

1. Hardware (техн. обеспечение): процессор, память, монитор, дисковые устройства и т.д.
2. Software (програм. обеспечение): системное, прикладное, средства разработки и т.д.  

К прикладному программному обеспечению относится разнообразные банковские и прочие бизнес-программы, игры, текстовые процессоры и т.д.
Под системным программным обеспечением обычно понимают программы, способствующие функционированию и разработке прикладных программ.
Деление на прикладное и системное программное обеспечение является отчасти условным и зависит от того, кто осуществляет такое деление.
Операционная система является частью системного программного обеспечения.

Основные функции операционной системы как защитника пользователей и программ:
- Обеспечение сохранности информации на диске, т.е защита от удаления или повреждения чужих файлов.   
- Защита от произвольного вмешательства в работу одних программ других пользователей.
- Пресечение попыток несанкционированного использования вычислительной системы.

Уровни (виды) интерфейсов:
- Пользовательский – предназначен для работы с готовыми приложениями.
- Программный (интерфейс прикладного программирования) – представляет собой средства для обращения к возможностям операционной системы при создании собственных приложений (фактически это системные функции, доступные разработчику).

Операционная система (ОС) это:
- Комплекс программ, обеспечивающих возможность рационального использования оборудования и программного обеспечения удобным для пользователя образом. 
- Система программ, реализующая интерфейс между аппаратурой ЭВМ и пользователя.
- Комплекс управляющих и обрабатывающих программ, который, с одной стороны, выступает как интерфейс между пользователем и аппаратными компонентами вычислительных машин и вычислительных систем, а с другой стороны предназначен для эффективного управления вычислительными процессами, а также наиболее рационального распределения и использования вычислительных ресурсов.

# Эволюция ОС
## 1-й период (1945 г.-1955 г.)

- Ламповые машины
    
- Нет разделения персонала
    
- Нет операционных систем
    
- Ввод программы с пульта или с колоды перфокарт
    
- Отладка программы с пульта
    
- Одновременное выполнение только одной операции
    
- Появление прообразов первых компиляторов

## **2-й период (1955 г. – начало 60-х)** 
 компьютеры на основе транзисторов. Пакетные операционные системы.

Новая элементная база – транзисторы:
- Повышение надежности вычислительной техники.
- Снижение энергопотребления.
- Упрощение систем охлаждения.
- Уменьшение размеров компьютеров.
- Снижение стоимости их эксплуатации и обслуживания.

Компьютеризация бизнеса.
Бурное развитие алгоритмических языков (Algol-58, Lisp, Cobol, Algol-60, PL-1, …), настоящие инструментальные системы.

Разделение персонала на программистов и операторов.
Задания (программа, входные данные, требуемые ресурсы), пакеты заданий.

Вычислительным процессом управляют системы пакетной обработки, имеющий формализованный язык управления заданиями.
## **3-й период (начало 60-х – 1980 г.)** 
компьютеры на основе ИМС. Первые многозадачные операционные системы.

Переход от транзисторов к интегральным микросхемам (ИМС):
- ВТ становится надёжной и дешёвой.
- Решаются многочисленные и сложные задачи.
- Растёт производительность процессоров.

“Бутылочное горлышко” – низкая скорость устройств ввода-вывода 
Буферизация

Режим off-line – операции ввода-вывода выполняются на отдельно стоящих компьютерах

On-line – spooling – на том же компьютере, который производит вычисления – прерывания.

Магнитные диски сменили магнитную ленту
Планирование заданий.
Мультипрограммирование.
Пока одна программа выполняет операцию ввода-вывода, процессор выполняет другую программу.

Аппаратная поддержка:
Защитные механизмы (привилегированные и непривилегированные команды)

Прерывания:
Внешние – произошло асинхронное событие.

Внутренние (исключительные ситуации) – ошибки нарушения защиты.

Мультипрограммирование привело к изменению операционных систем:
- Системные вызовы, как интерфейс между ОС и прикладными программами.
- Планирование заданий.
- Необходимость сохранения контекста (содержимого регистров и структур данных) при переключении задач.
- Стратегии управления памятью.
- Средства коммуникации и синхронизации между программами.

Всё же пользователь не мог непосредственно взаимодействовать с заданием.

Появились дисплеи на основе ЭЛТ и полноценные клавиатуры.

Мультипрограммирование time-sharing – системы, или системы разделения времени
- Процессор переключается между задачами не только во время операций ввода-вывода, но и просто через определённые промежутки времени.
- Многопользовательский режим.
- Механизм виртуальной памяти.
- Развитые файловые системы.

Семейства программно-совместимых машин (IBM/360 (OS/360 >=1000 известных ошибок), PDP (PDP-11).

## **4-й период (1980 – наше время)**
Персональные компьютеры. Классические, сетевые и распределённые системы.

Появление БИОС = возрастание степени интеграции + очередное удешевление.

Персональные компьютеры – деградация ОС (один пользователь в однозадачном режиме), интуитивно понятный интерфейс.

Возрождение ОС (автономные, сетевые и распределённые)

ПК стал своего рода бытовым прибором.

## Системные вызовы

System calls – интерфейс между ОС и прикладной программой (сервис).

Системные вызовы создают, используют и удаляют различные объекты: процессы, файлы и пр., переход задачи в привилегированный режим (kernel mode), осуществляется командой программного прерывания (INT) – синхронное событие (связано с выполняемым процессором кодом).

## Прерывания

Hardware interrupt – событие, генерируемое внешним (по отношению к процессору) устройством. (например, нажатие клавиши, завершилась асинхронная операция ввода-вывода, прерывания таймера)

Асинхронное событие – возникает независимо от того, какой код выполняется процессором в данный момент.

## Исключительные ситуации

Exception – возникает в результате выполнения программой недопустимой операции, доступа к ресурсу при отсутствии необходимых привилегий, или обращения к отсутствующей странице памяти.

Синхронные события, возникающие в контексте текущей задачи (как и системные вызовы)

- Исправимые (нет нужных данных в памяти)
    
- Неисправимые (ошибка в программе)  завершение программы

## Файлы

Файл (File) – часть пространства на носителе информации, имеющая имя.

Файловая система (file system) – скрывает особенности ввода-вывода и даёт программисту простую абстрактную модель файлов, независимую от устройств.

## Операционные оболочки

Операционная оболочка (operation shell) – комплекс программ, ориентированных на определённую операционную систему и предназначенный для облегчения диалога между пользователем и компьютером при выполнении определённых видов деятельности на компьютере.

Оболочка ОС – интерпретатор команд операционной системы, обеспечивающий интерфейс для взаимодействия пользователя с функциями системы.

# 2. Определение архитектуры ОС

Архитектура операционной системы – структурная и функциональная организация ОС на основе некоторой совокупности программных модулей.

Какой-либо единой унифицированной архитектуры ОС не существует, но известны универсальные подходы к структурированию ОС.

## Ядро

Ядро – ключевой, основной компонент операционной системы, именно в нём реализуется большая часть функциональности ОС.

Основные функции:
- Управление процессами
- Управление памятью
- Управление вводом-выводом и файловая система
- Интерфейс прикладного программирования для поддержки обращений к ядру из приложений.

Для обеспечения высокой скорости работы ОС модули ядра (все или большая часть), являются резидентными, т.е постоянно находятся в оперативной памяти.

## Вспомогательные модули

Выполняют полезные, но менее обязательные функции.

Обращаются к функциям ядра посредством системных вызовов.

Вспомогательные модули, в отличие от модулей ядра, являются транзитными – загружаются в оперативную память только на время выполнения.

(Утилиты + Системные обрабатывающие программы)  Ядро ОС (Приложения пользователей + Библиотеки процедур)

## Виды вспомогательных модулей

Утилиты – программы, решающие отдельные задачи управления и сопровождения компьютерной системы (сжатие дисков, их проверка, дефрагментация, архивирование, сбор статистики и т.д)

Системные обрабатывающие программы – загрузчики, отладчики, текстовые или графические редакторы)

Библиотеки процедур различного назначения для разработки приложений (математические функции, функции ввода-вывода и т.д)

Программы, предоставляющие дополнительные услуги (калькулятор, некоторые игры)

## Монолитное ядро

В монолитном ядре реализуются все основные функции операционной системы, и оно является, по сути, единой программой, представляющей собой совокупность процедур – большой набор сервисных функций.

Монолит – все вместе, все библиотеки, сервисные функции в одном ядре.

Базовые элементы монолитного ядра:
- Планирование процессов.
- Управление файловой системой.
- Сетевое взаимодействие.
- Драйверы устройств.
- Управление памятью.

## Монолитное ядро + и –
 
Преимущества:
- Производительность – в виду того, что количество переключений из контекста режима пользователя в режим ядра сведено к минимуму.|Неустойчивость к сбоям – так как все базовые элементы и их работа выполняются в режиме ядра, и если хотя бы в одном модуле или блоке ядра произойдёт какой-либо сбой, то ему будет подвержена вся ОС (всё ядро), вариантов других нет, закончится всё перезапуском ОС.

Недостатки: 
- Неустойчивость к сбоям – так как все базовые элементы и их работа выполняются в режиме ядра, и если хотя бы в одном модуле или блоке ядра произойдёт какой-либо сбой, то ему будет подвержена вся ОС (всё ядро), вариантов других нет, закончится всё перезапуском ОС.

Архитектура ОС, основанная на привилегированном ядре и приложениях пользовательского режима является классической = многослойный подход.

При таком подходе разработка системы осуществляется сверху вниз, от целей системы к их реализации.

Сначала определяются функции слоев и межслойные интерфейсы, задающие общую структуру системы, а затем разрабатываются модули внутри слоев.

(От -> К) Аппаратура -> Ядро ОС -> Утилиты, системные обрабатывающие программы, библиотеки процедур

Многослойный подход применим и к структуре ядра как сложного многофункционального комплекса.

Ядро = интерфейс системных вызовов, менеджеры ресурсов, базовые механизмы ядра, машинно-зависимые модули, средства аппаратной поддержки ОС.

## Резюме многослойной/классической/многоуровневой архитектуры.

Все компоненты ОС разделяются на модули, выполняющие основные функции ОС (ядро) и модули, выполняющие вспомогательные функции.

Вспомогательные модули оформляются либо в виде приложений, либо в виде библиотек процедур и функций.

Вспомогательные модули являются транзитными (загружаются в оперативную память только на время выполнения), модули ядра – резидентными (постоянно находятся в оперативной памяти).

Многослойная классическая многоуровневая архитектура ОС не лишена своих проблем.

1. Дело в том, что значительные изменения одного из уровней могут иметь трудно предвидимое влияние на смежные уровни.

2. Кроме того, многочисленные взаимодействия между соседними уровнями усложняют обеспечение безопасности.

Поэтому, как альтернатива классическому варианту архитектуры ОС, часто используется микроядерная архитектура ОС.

## Микроядро/микроядерная архитектура.

Микроядро – ядро, содержащее только самые необходимые функции.

Идея: минимизировать само ядро, вынести как можно функциональности в режим пользователя (т.е исполнять эту функциональность в виде обычных прроцессов).

Многие сервисы становятся пользовательскими процессами:
- Драйверы устройств
- Файловые системы
- Менеджер виртуальной памяти
- Оконные системы графического интерфейса пользователя
- Службы безопасности
- Данный подход популяризован ядром MACH (“Мак”)
- На основе MACH сделаны, среди прочих, MACOSX (комп. Apple, GNUHurd)

## Суть микроядерной архитектуры.

В привилегированном режиме остаётся работать очень небольшая часть ОС, называемая микроядром.

Микроядро защищено от остальных частей ОС и приложений. В его состав входят машинно-зависимые модули, а также модули, выполняющие базовые механизмы обычного ядра.

Все остальные, более высокоуровневые функции ядра оформляются как модули, работающие в пользовательском режиме. Так, менеджеры ресурсов, являющиеся неотъемлемой частью обычного ядра, становятся “периферийными” модулями, работающими в пользовательском режиме.

Таким образом, в архитектуре с микроядром традиционное расположение уровней по вертикали заменяется горизонтальным.

## Многослойная структура ядра ОС.

Средства аппаратной поддержки ОС – аппаратные средства, прямо участвующие в организации вычислительных процессов: средства поддержки привилегированного режима, система прерываний, переключение контекстов процессов, трансляция адресов, защита памяти и т.п.

Машино-зависимые модули – программные модули, в которых отоьражается специфика аппаратной платформы компьютера. В идеале этот слой полностью экранирует вышележащие слои от особенностей аппаратуры, т.е позволяет делать модули вышележащих слоев машинно-независимыми.

На уровне HAL работа с устройством определённого типа (накопитель, видеоплата, мышь и т.п) всегда описывается при помощи одного и того же заранее определённого набора функций. В случае, если устройство имеет иной набор функций (например, устаревший 3d-ускоритель может не поддерживать многих современных функций), драйвер обязан эмулировать стандартные функции с тем, чтобы OC могла не заботиться о том, какое конкретно устройство установлено.

Экранировать – предохранять от посторонних воздействий.

Эмуляция – один из способов электронного архивированная устаревающих вычислительных систем.

## Многослойная структура ядра ОС

Базовые механизмы ядра. Модули этого слоя не принимают решений о распределении ресурсов, а только отрабатывают принятые на более высоком уровне решения. Выполняются наиболее примитивные операции ядра: программное переключения контекстов процессов, перемещение страниц между памятью и диском, диспетчеризация прерываний и т.п.

Менеджеры ресурсов. Модули этого уровня реализуют управление основными ресурсами системы. Группировка модулей в менеджеры обычно осуществляется по функциям основных подсистем ОС: выделяются менеджеры процессов, ввода-вывода и файловой системы (могут быть объединены), оперативной памяти.

Интерфейс системных вызовов. Взаимодействует непосредственно с приложениями и системными утилитами, образуя прикладной программный интерфейс ОС (API).

## Загрузчик операционной системы

Загрузчик ОС – системное ПО, обеспечивающее загрузку ОС непосредственно после включения компьютера.

- Обеспечивает необходимые средства для диалога с пользователем компьютера (например, загрузчик позволяет выбрать ОС для загрузки).
    
- Приводит аппаратуру компьютера в состояние, необходимое для старта ядра ОС.
    
- Загружает ядро ОС в ОЗУ.
    
- Формирует параметры, передаваемые ядру ОС (например, ядру Linux передаются параметры, указывающие способ подключения корневой файловой системы).
    
- Передаёт управление ядру ОС.
    

Базовая система ввода-вывода – набор программных средств, обеспечивающих взаимодействие ОС и приложений с аппаратными средствами. Обычно базовая система ввода-вывода представляет собой набор драйверов.

Командный интерпретатор – необязательная, но присутствующая в большинстве операционных систем часть, которая обеспечивает управление системой посредством ввода текстовых команд.

Сервисное программное обеспечение – пакет приложений, включённый в состав ОС, реализующий множество полезных функций.

## Экзоядро ОС

Такое ядро ОС, которое представляет лишь функции взаимодействия процессов, безопасное выделение и распределение ресурсов. Доступ к устройствам на уровне контроллеров позволяет решать задачи, которые нехарактерны для универсальной ОС.

## Наноядро ОС

Такое ядро выполняет только единственную задачу-обработку аппаратных прерываний, образуемых устройствами ПК. После обработки наноядро посылает данные о результатах обработки далее идущему в цепи программному обеспечению при той же системы прерываний. Примером является KeyKOS – самая первая ОС на наноядре. Первая версия вышла ещё в 1983-м году.

## Гибридное ядро ОС

Модификация микроядер, позволяющая для ускорения работы впускать несущественные части в пространство ядра. На архитектуре гибкого ядра построены последние операционные системы от Windows, в том числе и Windows 7-10.

## Предпосылки возникновения ОС GNU/Linux

Unix -> GNU, Linux, Minix (учебная ОС)

Minix, GNU -> Linux

GNU (различное ПО), Linux (ядро ОС) -> GNU/Linux (Множество подобных ОС(дистрибутивов))

## История развития программных языков

Fortran -> Algol 60

Fortran, Algol 60 -> PL/I -> Cobol

Algol 60 -> Algol 68

Algol 60 -> C, Simula, Pascal

Simula -> Smalltalk

Simula, Pascal -> Ada

Simula, C -> C++

Иерархическая система структура – многоуровневая форма организации объектов со строгой соответственностью объектов нижнего уровня определённому объекту верхнего уровня.

Графически представляется в виде дерева.

MULTICS -> UNICS -> UNIX -> MINIX -> Linux

UNIX -> BSD -> FreeBSD -> MacOSX

BSD -> NeXTSTEP -> MacOSX

BSD -> NetBSD -> OpenBSD

## Методы распределения памяти

Все алгоритмы распределения памяти разделены на два класса:
- Алгоритмы, в которых используется перемещение сегментов процессов между оперативной памятью и диском.
- Алгоритмы, в которых внешняя память не привлекается.

Алгоритмы, в которых внешняя память не привлекается:
Распределение памяти фиксированными, динамическими, перемещаемыми разделами.

## Распределение памяти динамическими разделами

В этом случае память машины не делится заранее на разделы.

Сначала вся память, отводимая для приложений, свободна.

Каждому вновь поступающему на выполнение приложению на этапе создания процесса выделяется вся необходимая ему память (если достаточный объём памяти отсутствует, то приложение не принимается на выполнение и процесс для него не создаётся).

После завершения процесса память освобождается и на это место может быть загружен другой процесс.

## Распределение памяти перемещаемыми разделами

Одним из методов борьбы с фрагментацией является перемещение всех занятых участков в сторону старших или младших адресов, так, чтобы вся свободная память образовала единую свободную область.

В дополнение к функциям, которые выполняет ОС при распределении памяти динамическими разделами в данном случае она должна ещё время от времени копировать содержимое разделов из одного места памяти в другое, корректируя таблицы свободных и занятых областей – процедура называется сжатием.

Для преодоления перегрузки памяти были выработаны два основных подхода:
1. Самый простой – свопинг. Заключается в размещении в памяти всего процесса целиком, в запуске его на некоторое время, а затем в сбросе его на диск. Бездействующие процессы большую часть времени хранятся на диске и в нерабочем состоянии не занимают пространство оперативной памяти.
2. Виртуальная память, она позволяет программам запускаться даже в том случае, если они находятся в оперативной памяти лишь частично.

## Виртуальная память

Виртуальная память –
- Это подход к управлению памятью компьютером, который скрывает физическую память (в различных формах, таких как: оперативная память или жёсткие диски) за единым интерфейсом, позволяя создавать программы, которые работают с ними как с единым непрерывным массивом памяти с произвольным доступом.
- Это метод управления памятью, которая реализуется с использованием аппаратного и программного обеспечения компьютера.

Она отображает используемые программами виртуальные адреса в физические адреса в памяти компьютера.

Основная память представляется в виде непрерывного адресного пространства или набора смежных непрерывных сегментов.

К основным преимуществам виртуальной памяти относят:
- Избавление программиста от необходимости управлять общим пространством памяти.
- Повышение безопасности использования программ за счёт выделения памяти.
- Возможность иметь в распоряжении больше памяти, чем это может быть физически доступно на компьютере.

Виртуальная память делает программирование приложений проще:
- Скрывая фрагментацию физической памяти.
- Устраняя необходимость в программе для обработки наложений в явном виде.
- Когда каждый процесс запускается в своем собственном выделенном адресном пространстве, нет необходимости переместить код программы или получить доступ к памяти с относительной адресацией.

Страничное распределение

При таком способе все фрагменты программы, на которые она разбивается (кроме последней части) получаются одинаковыми.

Одинаковыми должны быть и единицы памяти, предоставляемые для размещения фрагментов программы.

Каждая программа ссылается на часть своего адресного пространства, находящегося в физической памяти, то операция выполняется сразу.

## Страничная организация памяти.

С точки зрения программиста:

Процессам виртуальное адресное пространство представляется непрерывным, от 0 байта до N байта.

N зависит от аппаратной поддержки (например, 32 бит – адр.пространство 4 гб), делится соответственно.

В реальности виртуальные страницы распределены по страницам физической памяти далеко непрерывно и не один к одному.

Это два разных мира – физические страницы и виртуальные страницы.

Страничный способ организации виртуальной памяти – способ разрывного размещения задач в памяти, при котором все фрагменты задачи имеют одинаковый размер, кратный степени двойки (для использования памяти конкатенации)

Виртуальный адрес состоит из двух полей:
1. Указатель на часть программы (с которой идёт работы) для определения местоположения этой части.
2. Относительный адрес нужного фрагмента памяти.

## Трансляция адресов

Трансляция виртуального адреса:
- Виртуальный адрес состоит из двух частей: номер виртуальный страницы (VPN) и смещение внутри страницы.
- Номер виртуальной страницы (VPN – virtual page number) – индекс в таблице страниц.
- Запись в таблице страниц (PTE – page table entry) содержит номер фрейма (PFN – page frame number)
- Фрейм – страница физической памяти.
- Номер фрейма (PFN) – номер физической страницы.

Смысл таблицы страниц – одна запись в таблице страниц (PTE) на одну страницу виртуального адресного пространства (VPN), отображает VPN на PFN. Какая виртуальная страница соответствует какому фрейму физической памяти.

## Таблица страниц

Запись в таблице – дескриптор страницы.

Номер физической страницы, в которую загружена данная виртуальная страница.

Признак присутствия = 1, если виртуальная страница в ОП.

Признак модификации страницы -> 1, когда производится запись по адресу, относящемуся к данной странице.

Признак обращения (бит доступа) -> 1, при каждом обращении по адресу, относящемуся к данной странице.

## Страничное прерывание

Номер виртуальной страницы -> определяется нужный элемент таблицы страниц -> извлечение информации о станице (в том числе адрес в ОП)

Анализ признака присутствия, если страница в ОП есть -> преобразование адреса (ВА – ФА), если страницы нет, то страничное прерывание (действия).

Это происходит в 2 этапа:
1. Посредством системы программирования.
2. Посредством ОС (с помощью специальных программных модулей управления памятью и использования соответствующих аппаратных средств вычислительной системы).

Страничная память – способ организации виртуальной памяти, при котором единицей отображения виртуальных адресов на физические является фрагмент постоянного размера – страница.

При использовании страничной модели вся виртуальная память делится на N страниц таким образом, что часть виртуального адреса интерпретируется как номер страницы, а часть – как смещение внутри страницы.

## Сегментное распределение - вывод

Сегментная организация виртуальной памяти реализует следующий механизм: вся память делиться на сегменты фиксированной или произвольной длины, каждый из которых характеризуется своим начальным адресом.

Виртуальный адрес в такой системе состоит из 2-х компонентов: базы сегмента, к которому мы хотим обратиться и смещения внутри сегмента.

## Страничное-сегментное распределение

Данный метод представляет собой комбинацию страничного и сегментного распределения памяти и, вследствие этого, сочетает в себе достоинства обоих подходов.

Виртуальное пространство процесса делится на сегменты, а каждый сегмент в свою очередь делится на виртуальные страницы, которые нумеруются в пределах сегмента.

Оперативная память делится на физические страницы.

Виртуальное адресное пространство зависит от:
- Архитектуры процессора
- Системы программирования

Виртуальное адресное пространство не зависит от объёма реальной физ.памяти, установленной в компьютере.

Все методы управления памятью могут быть разделены на два класса:
- Методы, которые используются перемещение процессов меду оперативной памятью и диском.
- Методы, которые не делают этого.

Методы распределения памяти без исп.внешн.памяти:
- Распределение памяти фиксированными разделами.
- Распределение памяти разделами переменной величины.
- Перемещаемые разделы.

Подсистема управления памятью в этом случае выполняет следующие задачи:
- Сравнивая размер программы, поступившей на выполнение, и свободных разделов, выбирает подходящий раздел.
- Осуществляет загрузку программы и настройку адресов.

Методы распределения памяти без использования внешней памяти:
- Распределение памяти фиксированными разделами.
- Распределение памяти разделами переменной величины.
- Перемещаемые разделы.

При распределении памяти разделами переменной величины память машины не делится заранее на разделы. Сначала вся память свободна. Каждой вновь поступающей задаче выделяется необходимая ей память.

Если достаточный объём памяти отсутствует, то задача не принимается на выполнение и стоит в очереди.

После завершения задачи память освобождается, и на это место может быть загружена другая задача.

Виртуальный адрес можно представить состоящим из двух полей:
- Указатель на часть программы (с которой идёт работы) для определения местоположения этой части
- Относительный адрес нужной ячейки памяти (по отношению к найденному адресу)

При сегментно-страничном способе организации виртуальной памяти программа разбивается на логически законченные части – сегменты, виртуальный адрес содержит указание на номер соответствующего сегмента.

# Введение в Docker

Для чего нужен (или плюсы):
1. Изолированный запуск приложений в контейнерах.
2. Упрощение разработки, тестирования и деплоя приложений.
3. Отсутствие необходимости конфигурировать среду для запуска – она поставляется вместе с приложением в контейнере.
4. Упрощает масштабируемость приложений и управление их работой с помощью систем оркестрации контейнеров.

**Компоненты** **Docker Engine**:

Сервер (Docker Demon)

Rest API

Docker клиент (CLI) – сеть (network), контейнер (container), образ (image), тома с данными (data volumes)

## Образ

Read-only шаблон с набором инструкций, предназначенных для создания контейнера

Образ состоит из неизменяемых слоев, каждый из которых добавляет/удаляет/изменяет файлы из предыдущего слоя.

Неизменяемость слоев позволяет их использовать совместно в разных образах.

## Docker

$docker ps – отображает список запущенных контейнеров

$docker ps -a – отображает список всех контейнеров в системе

$docker run run –rm –p 8888:80 nginx – связывает локальный порт хостовой машины с портом приложения в контейнере

При запуске образа docker скачивает образ, создаёт контейнер, инициализирует файловую систему и монтирует read-only образ, инициализирует сеть/мост, запускает указанный процесс, обрабатывает и выдаёт вывод приложения.

$docker stop `[container]` – останавливает работу контейнера

$docker images – отображает список доступных локально образов

## Dockerfile, инструкции для подготовки образа

Сборка образа из Dockerfile

$docker build .t hello_world

$docker run –rm hello_world

Docker-compose – инструментальное средство, предназначенное для решения задач, связанных с развёртыванием проектов.

## Установка docker-compose (Linux)

_Скачиваем_ _docker-compose_ _сразу_ _в_ _папку_ _/usr/local/bin:_

$sudo curl -L “ссылка” -o /usr/local/bin/docker-compose

_Устанавливаем_ _разрешение_ _на_ _запуск_

$sudo chmod +x /usr/local/bin/docker-compose

_Проверяем_

$docker-compose – version

## Основные команды

$ docker-compose up

Создаёт все зависимости (сеть, volumes) для запуска сервисов, скачивает или собирает образы и запускает все сервисы docker-compose

$ docker-compose down

Останавливает все запущенные сервисы, удаляет контейнеры, сети, вольюмы и образы, созданные командой up.

$ docker-compose build

Собирает образы всех сервисов проекта

$ docker-compose run –rm `[service] [command]`

Запускает команды в контейнере. Аргумент rm по аналогии с docker удаляет контейнер после остановки

$ docker-compose logs -f `[service]`

Просмотр логов контейнера. -f выводит логи после запуска команды до остановки работы logs или контейнера.

# Классификация угроз по цели:

- Несанкционированное чтение информации
    
- Несанкционированное изменение информации
    
- Несанкционированное уничтожение информации
    
- Полное или частичное уничтожение ОС (от кратковременного вывода из строя программных модулей до физического стирания их с диска системных файлов)

# Классификация угроз по принципу воздействия на ОС:

- Использование известных (легальных) каналов получения информации, например, несанкционированного чтения пользователя которому доступ ограничен
    
- Использование скрытых каналов получения информации, например, угроза использования злоумышленником недокументированных возможностей ОС
    
- Создание новых каналов получения информации с помощью программных закладок

Классификация угроз по принципу воздействия на ОС:
1. Активное воздействие – несанкционированные действия злоумышленника в системе.
2. Пассивное воздействие – несанкционированные наблюдения злоумышленника за процессами происходящими в системе.

Разновидности кибератак:
1. Массовые угрозы (90%)
2. Более сложные атаки (9.9%)
3. Самые сложные в техническом плане атаки (0.1%)

Классификация угроз по типу используемой злоумышленником слабости защиты:
- Неадекватная политика безопасности, в том числе ошибки администратора системы
- Ошибки и недокументированные возможности программного обеспечения ОС, в том числе и так называемые люки – случайно или преднамеренно встроенные в систему “служебные входы”, позволяющие обходить систему.

**Процесс** – абстрактное понятие, описывающие работу программы.

В современных ОС многозадачность реализована за счёт предоставления пользовательской программе процессора на несколько миллисекунд. При условии чередования использования процессора между программами.

## Модель процесса

Все ПО, исполняемое на ПК, а иногда и ОС, организовано в виде последовательных процессов.

Процессом является выполняемая программа, включая:
- Текущие значения счетчиков команд
- Текущие значения регистров
- Текущие значения переменных

В отдельно взятый момент времени активна только одна программа.

Центральный процессор переключается между процессами, следовательно, скорость вычислений процесса всегда будет разной.

Процессы не должны программироваться с жестко заданным временем выполнения.

Планирование процессов.

Программа и процесс понятия схожие, но разные!

Если программа запущенная дважды, то ею заняты два процесса.

## Создание процесса

В универсальных системах определённые способы создания и прекращения процессов по мере необходимости.

Способы создания процессов:
1. Инициализация системы
2. Выполнение работающим процессом системного запроса на создание процесса
3. Запрос пользователя на создание процесса
4. Инициализация пакетного задания

При загрузке ОС создается несколько процессов:
- Процессы, обеспечивающие взаимодействие с пользователями и выполнение заданий, являются высокоприоритетными процессами.
- Процессы, не связанные с конкретными пользователями, но выполняющими ряд специфических функций, являются фоновыми процессами (демонами)

Новый процесс формируется на основании системного запроса от текущего процесса.

В роли текущего процесса может выступать:
- Процесс, запущенный пользователем.
- Системный процесс.
- Процесс, инициализированный устройством ввода.
- Процесс, управляющий пакетами.

Завершение процесса:
1. Обычный выход (преднамеренно).
2. Выход по ошибке (преднамеренно).
3. Выход по неисправимой ошибке (непреднамеренно)
4. Уничтожение другим процессом (непреднамеренно)

Состояние процессов:
1. Работающий
2. Готовый к работе
3. Заблокированный

- Процесс блокируется, ожидая входных данных.
    
- Планировщик выбирает другой процесс
    
- Планировщик выбирает этот процесс
    
- Доступные входные данные

Реализация процессов

| Управление процессом                  | Управление памятью             | Управление файлами |
| ------------------------------------- | ------------------------------ | ------------------ |
| Регистры                              | Указатель на текстовый сегмент | Корневой каталог   |
| Счетчик команд                        | Указатель на сегмент данных    | Рабочий каталог    |
| Слово состояния программы             | Указатель на сегмент диска     | Дескрипторы файла  |
| Указатель стека                       | Идентификатор пользователя     |                    |
| Состояние процесса                    | Идентификатор группы           |                    |
| Приоритет                             |                                |                    |
| Параметры планирования                |                                |                    |
| Идентификатор процесса                |                                |                    |
| Родительский процесс                  |                                |                    |
| Группа процесса                       |                                |                    |
| Сигналы                               |                                |                    |
| Время начала процесса                 |                                |                    |
| Использованное процессорное время     |                                |                    |
| Процессорное время дочернего процесса |                                |                    |
| Время следующего аварийного сигнала   |                                |                    |
Реализация процессов (схема обработки прерываний)
1. Аппаратное обеспечение сохраняет в стеке счетчик команд и т.п
2. Аппаратное обеспечение загружает новый счетчик команд из вектора пребываний
3. Процедура на ассемблере сохраняет регистры
4. Процедура на ассемблере устанавливает новый стек
5. Запускается программа обработки прерываний на С
6. Планировщик выбирает следующий процесс
7. Программа на С передает управление процедуре на ассемблере
8. Процедура на ассемблере запускает новый процесс

## Использование потоков. Пример. WEB-сервер.

Способ организации web-сервера:
1. Один поток, называемый диспетчером, считывает приходящие по сети запросы.
2. После этого он находит свободный (то есть блокированный) рабочий поток и передаёт ему запрос, скажем, записывая указатель сообщения в специальное слово, связанное с каждым потоком.
3. Затем диспетчер активизирует ждущий поток, переводя его из состояния блокировки в состояние готовности.

## Модель потока. Группировка ресурсов.

Процесс можно рассматривать как способ объединения родственных ресурсов в 1 группу.

У процесса есть адресное пространство, содержащее текст программы и данные, а также другие ресурсы.

Ресурсами являются: открытые файлы, дочерние процессы, необработанные аварийные сообщения, обработчики сигналов и м.д.

Гораздо проще управлять ресурсами, объединив их в форме процесса.

## Модель потока. Выполнение программы.

Процесс можно рассматривать как поток исполняемых команд или просто поток.

Компоненты потока:

Счетчик команд, отслеживающий порядок выполнения действий.

Регистры, в которых хранятся текущие переменные.

Стек, содержащий протокол выполнения процесса.

## Отличия потока от процесса.

Процессы используется для группирования ресурсов, а потоки являются субъектами, поочерёдно исполняющимися на ЦП.

Различные потоки в одном процессе не так зависимы, как различные процессы. У всех потоков одно и то же адресное пространство, что означает совместное использование глобальных переменных.

Любой поток имеет доступ к любому адресу ячейки памяти в адресном пространстве процесса, один поток может считывать, записывать или ддаже стирать информацию из стека другого потока.

Защиты не существует, поскольку: это невозможно и – это ненужно. В отличие от различных процессов, которые инициированы различными пользователями, один процесс всегда запущен 1 пользователем, и потоки созданы, чтобы работать совместно.

| Элементы процесса                    | Элементы потока |
| ------------------------------------ | --------------- |
| Адресное пространство                | Счетчик команд  |
| Глобальные переменные                | Регистры        |
| Открытые файлы                       | Стек            |
| Дочерние процессы                    | Состояние       |
| Необработанные аварийные сигналы     |                 |
| Сигналы и их обработчики             |                 |
| Информация об использовании ресурсов |                 |
 
## Потоки в POSIX

IEEE standart 1003.1c – стандарт создания переносимых многопоточных программ

Пакет Pthreads, реализует работу с потоками, поддерживается большинством UNIX-систем.

В стандарте определено более 60 вызовов функций.

Все потоки Pthreads имеют опред.свойства.

У каждого потока есть свой ID, набор регистров, атрибутов. В атрибуты входят размер стека, параметры планирования и др.элементы, необходимые для использования потока.

Вызовы, связанные с потоком и их описание

Pthread_create – создание потока

Pthread_exit – завершение вызвавшего потока

Pthread_join – ожидание выхода из указанного потока

Pthread_vield - освобождение ЦП, позволяющее выполняться другому потоку

Pthread_attr_init – создание и инициализация структуры атрибутов потока

Pthread_attr_destroy – удаление структуры атрибутов потока

Есть 2 основных способа реализации пакета потоков: в пространстве пользователя и ядре.

## Активация планировщика

Цель активации планировщика заключается в имитации функциональных возможностей потоков на уровне ядра, но при лучшей производительности и более высокой гибкости, свойственной пакетам потоков, реализуемых в пользовательском пространстве.

Пользовательские потоки не должны осуществлять специальные неблокирующие системные вызовы.

Когда поток блокируется на системном вызове или на ошибке обращения к отсутствующей странице, должна оставаться возможность выполнения другого потока в рамках того же процесса.

Эффективность достигается путем уклонения от ненуных переходов между пространствами пользователя и ядра.

## Всплывающие потоки

Потоки часто используются в распределённых системах.

Как пример: email.

При поступлении сообщения система создаёт новый поток для его обработки, называется всплывающий поток.

Основное преимущество всплывающих потоков заключается в том, что они создаются заново и не имеют прошлого – никаких регистров, стека и всего остального, что должно быть восстановлено. Каждый такой поток начинается с чистого листа, и каждый из них идентичен всем остальным.

## Состояние состязания

В некоторых операционных системах процессы, работающие совместно, могут сообща использовать некое общее хранилище данных. Каждый из процессов может считывать из общего хранилища данных и записывать туда информацию. Это хранилище представляет собой участок в основной памяти или файл общего доступа.

Если процессу требуется вывести на печать файл, он помещает имя файла в спец. Каталог спулера. Другой процесс, демон печати, проверяет наличие файлов, которые нужно печатать, печатает файл и удаляет его имя из каталога.

## Критические области. Состязания между процессами.

Основной способ предотвращения любой ситуации, связанной с совместным исп. памяти, файлов и чего-либо ещё, является запрет одновременной записи и чтения разделённых данных более чем 1 процессом.

Взаимн.исключение: один процесс использует разделенные данные, другому процессу это будет делать будет запрещено.

Формулировка состояния состязания:
1. Некоторый промежуток времени процесс занят внутренними расчетами и другими задачами, не приводящими к состояниям состязания.
2. В другие моменты времени процесс обращается к совместно используемым данным или выполняет действие, которое может привести к состязанию.
3. Часть программы, в которой есть обращение к совместно используемым данным, называется крит.областью или крит.секцией.
4. Если удастся избежать одновременного нахождения двух процессоров в крит.областях, можно избежать состязаний.

## Крит.области

Для правильной совместной работы параллельных процессов и эффективного использования общих данных необходимо выполнение четырёх условий:
1. Два процесса не должны одновременно находиться в крит.областях.
2. В программе не должно быть предположений о скорости или кол-ве процессоров.
3. Процесс, находящийся вне критической области, не может блокировать другие процессы.
4. Невозможна ситуация, в которой процесс вечно ждёт попадания в крит.область.

# Планирование в системах пакетной обработки заданий

## Первым пришел – первым ушел (FIFO)

- Алгоритм без переключений «первым пришел – первым обслужен» является, пожалуй, самым простым из алгоритмов планирования. Процессам предоставляется доступ к процессору в том порядке, в котором они его запрашивают. Чаще всего формируется единая очередь ждущих процессов. Как только появляется первая задача, она немедленно запускается и работает столько, сколько необходимо.
    
- Остальные задачи ставятся в конец очереди. Когда текущий процесс блокируется, запускается следующий в очереди, а когда блокировка снимается, процесс попадает в конец очереди. Основным преимуществом этого алгоритма является то, что его легко понять и столь же легко программировать. Он справедлив в том же самом смысле, в каком справедливо распределение дефицитных билетов на концерт или соревнования среди всех желающих стоять в очереди с двух часов ночи. В этом алгоритме все процессы в состоянии готовности контролируются одним связным списком. Чтобы выбрать процесс для запуска, нужно всего лишь взять первый элемент списка и удалить его. Появление нового процесса приводит к помещению его в конец списка – что может быть проще?

## «Кратчайшая задача – первая»

- Рассмотрим еще один алгоритм без переключений для систем пакетной обработки, предполагающий, что временные отрезки работы известны заранее.
    
- Например, работники страховой компании могут довольно точно предсказать, сколько времени займет обработка Пакета из 1000 исков, поскольку они делают это каждый день. Если в очереди есть несколько одинаково важных задач, планировщик выбирает первой самую короткую задачу.

## Наименьшее оставшееся время выполнения

- Версией предыдущего алгоритма с переключениями является алгоритм наименьшего оставшегося времени выполнения.
    
- В соответствии с этим алгоритмом планировщик каждый раз выбирает процесс с наименьшим оставшимся временем выполнения.
    
- В этом случае также необходимо заранее знать время выполнения задач.
    
- Когда поступает новая задача, ее полное время выполнения сравнивается с оставшимся временем выполнения текущей задачи.
    
- Если время выполнения новой задачи меньше, текущий процесс приостанавливается и управление передается новой задаче.
    
- Эта схема позволяет быстро обслуживать короткие запросы.

## Трехуровневое планирование

- Системы пакетной обработки позволяют реализовать трехуровневое планирование. По мере поступления в систему новые задачи сна­чала помещаются в очередь, хранящуюся на диске.
    
- Впускной планировщик выбирает задание и передает его системе. Остальные задания остаются в очереди. Характерный алгоритм входного контроля может заключаться в выборе смеси из процессов, ограниченных возможностями процессора, и процессов, ограниченных возможностями устройств ввода-вывода.
    
- Также возможен алгоритм, в котором устанавливается приоритет коротких задач перед длинными.
    
- Впускной планировщик волен придержать некоторые задания во входной очереди, а пропустить задание, поступившее позже остальных.

## Циклическое планирование

- Одним из наиболее старых, простых, справедливых и часто используемых является алгоритм циклического планирования. Каждому процессу предоставля­ется некоторый интервал времени процессора, так называемый квант времени.
    
- Если к концу кванта времени процесс все еще работает, он прерывается, а управление передается другому процессу. Разумеется, если процесс блокируется или прекращает работу раньше, переход управления происходит в этот момент. Реа­лизация циклического планирования проста. Планировщику нужно всего лишь поддерживать список процессов в состоянии готовности. Когда процесс исчерпал свой лимит времени, он отправляется в конец списка.

## Приоритетное планирование

- Необходимость принимать во внимание подобные внешние факторы приводит к приоритетному планированию. Основная идея проста: каждому процессу присваивается приоритет, и управление передается готовому к работе процессу с самым высоким приоритетом.
    
- Даже на персональном компьютере с одним пользователем может происходить несколько процессов, отдельные из которых являются более важными, чем другие. Демон, отвечающий за пересылку электронной почты в фоновом режиме, имеет более низкий приоритет, чем процесс, отображающий на экране видеофильм в реальном времени.
    
- Приоритеты процессам могут присваиваться статически или динамически.

## Несколько очередей

- Один из первых приоритетных планировщиков был реализован в системе CTSS (compatible time-shared system - совместимая система с разделением времени).
    
- В результате было разработано решение с классами приоритетов. Процессам клас­са с высшим приоритетом выделялся один квант, процессам следующего класса - два кванта, следующего - четыре кванта и т. д. Когда процесс использовал все от­веденное ему время, он перемещался на класс ниже. В качестве примера рассмотрим процесс, которому необходимо производить вычисления в течение 100 квантов. Вначале ему будет предоставлен один квант, затем он будет перекачан на диск. В следующий раз ему достанется 2 кванта, за­тем 4, 8,16, 32, 64, хотя из 64 он использует только 37.

## “Самый короткий процесс - следующий”

- Поскольку алгоритм «Кратчайшая задача - первая» минимизирует среднее оборот­ное время в системах пакетной обработки, хотелось бы использовать его и в инте­рактивных системах. Интерактивные процес­сы чаще всего следуют схеме «ожидание команды, исполнение команды, ожида­ние команды, исполнение команды...» Если рассматривать выполнение каждой команды как отдельную задачу, можно минимизировать общее среднее время от­клика, запуская первой самую короткую задачу.
    
- Один из методов основывается на оценке длины процесса, базирующейся на предыдущем поведении процесса. При этом запускается процесс, у которого оце­ненное время самое маленькое. Допустим, что предполагаемое время исполнения команды равно Т0 и предполагаемое время следующего запуска равно Т1. Можно улучшить оценку времени, взяв взвешенную сумму этих времен аТ0 + (1 - а)Т1.
    
- Метод оценки следующего значения серии через взвешенное среднее предыдущего значения и предыдущей оценки часто называют старением.

## Гарантированное планирование

- Принципиально другим подходом к планированию является предоставление пользователям реальных обещаний и затем их выполнение. Вот одно обещание, которое легко произнести и легко выполнить: если вместе с вами процессором пользуются n пользователей, вам будет предоставлено 1 / n мощности процессора.
    
- И в системе с одним пользователем и n запущенными процессорами каждому достанется 1 / n циклов процессора. Чтобы выполнить это обещание, система должна отслеживать распределение процессора между процессами с момента создания каждого процесса. Затем система рассчитывает количество ресурсов процессора, на которое процесс имеет право, например, время с момента создания, деленное на n. Теперь можно сосчитать отношение времени, предоставленного процессу, к времени, на которое он имеет право. Полученное значение 0.5 означает, что процессу выделили только полови­ну положенного, а 2.0 означает, что процессу досталось в два раза больше, чем положено. Затем запускается процесс, у которого это отношение наименьшее, пока оно не станет больше, чем у его ближайшего соседа.

## Лотерейное планирование

- Хотя идея обещаний пользователям и их выполнения хороша, но ее трудно реализовать. Для более простой реализации предсказуемых результатов используется другой алгоритм, называемый лотерейным планированием.
    
- В основе алгоритма лежит раздача процессам лотерейных билетов на доступ к различным ресурсам, в том числе и к процессору. Когда планировщику необходимо принять решение, выбирается случайным образом лотерейный билет, и его обладатель получает доступ к ресурсу. Что касается доступа к процессору, «лотерея» может происходить 50 раз в секунду, и победитель получает 20 мс времени процессора.

# Взаимное исключение с активным ожиданием
**Способы реализации**

## Запрещение прерываний

- Запрет всех прерываний при входе процесса в критическую область и разрешение прерываний по выходе из области.
    
- Если прерывания запрещены, невозможно прерывание по таймеру. Поскольку процессор переключается с одного процесса на другой только по прерыванию, отключение прерываний исключает передачу процессора другому процессу.

## Переменные блокировки

Рассмотрим одну совместно используемую переменную блокировки, изначально равную 0.

- Если процесс хочет попасть в критическую область, он предварительно считывает значение переменной блокировки.
    
- Если переменная равна 0, процесс изменяет ее на 1 и входит в критическую область.
    
- Если же переменная равна 1, то процесс ждет, пока ее значение сменится на 0.

## Переменные блокировки (недостатки)

- Один процесс считывает переменную блокировки, обнаруживает, что она равна 0, но прежде, чем он успевает изменить ее на 1, управление получает другой процесс, успешно изменяющий ее на 1.
    
- Когда первый процесс снова получит управление, он тоже заменит переменную блокировки на 1 и два процесса одновременно окажутся в критических областях.  

## Строгое чередование

- Переменная turn=0 отслеживает, чья очередь входить в критическую область.
    

1. Вначале процесс 0 проверяет значение turn, считывает 0 и входит в критическую область.
    
2. Процесс 1 также проверяет значение turn, считывает 0 и после этого входит в цикл, непрерывно проверяя, когда же значение turn будет равно 1.
    

- Постоянная проверка значения переменной в ожидании некоторого значения называется активным ожиданием. Активное ожидание используется только в случае, когда есть уверенность в небольшом времени ожидания.
    
- Блокировка, использующая активное ожидание, называется спин-блокировкой.

## Команда TSL

Рассмотрим решение, требующее участие аппаратного обеспечения. Многие компьютеры, особенно разработанные с расчетом на несколько процессоров, имеют команду `TSL RX.LOCK` (Test and Set Lock) – проверить и заблокировать), которая действует следующим образом:
В регистр RX считывается содержимое слова памяти lock, а в ячейке памяти lock сохраняется некоторое ненулевое значение. Гарантируется, что операция считывания слова и сохранения неделима – другой процесс не может обратиться к слову в памяти, пока команда не выполнена.

## Примитивы межпроцессного взаимодействия

- Оба решения – Петерсона и с использованием команды TSL – корректны, но они обладают одним и тем же недостатком: использованием активного ожидания.
    
- В сущности, оба они реализуют следующий алгоритм: перед входом в критическую область процесс проверяет, можно ли это сделать. Если нельзя, процесс входит в тугой цикл, ожидая возможности войти в критическую область.

## Примитивы межпроцессного взаимодействия. Пример.

- Этот алгоритм не только бесцельно расходует время процессора, но, кроме этого, он может иметь некоторые неожиданные последствия.
    
- Рассмотрим два процесса: H, с высоким приоритетом и L, с низким приоритетом. Правила планирования в этом случае таковы, что процесс H запускается немедленно, как только он оказывается в состоянии ожидания. В какой-то момент, когда процесс L находится в критической области, процесс H оказывается в состоянии ожидания. Процесс H попадает в состояние активного ожидания, но поскольку процессу L во время работающего процесса H никогда не будет предоставлено процессорное время, у процесса L не будет возможности выйти из критической области, и процесс H навсегда останется в цикле. Эту ситуацию иногда называют проблемой инверсии приоритета.  

## Примитивы межпроцессного взаимодействия

- Теперь рассмотрим некоторые примитивы межпроцессного взаимодействия, применяющиеся вместо циклов ожидания, в которых лишь напрасно расходуется процессорное время. Эти примитивы блокируют процессы в случае запрета на вход в критическую область. Одной из простейших является пара примитивов sleep и wakeup.
    
- Примитив sleep – системный запрос, в результате которого вызывающий процесс блокируется, пока его не запустит другой процесс.
    
- Примитив wakeup есть один параметр – процесс, который следует запустить. Также возможно наличие одного параметра у обоих запросов – адреса ячейки памяти, используемой для согласования запросов ожидания и запуска.

## Семафоры. Операции: down и up.

- Операция down сравнивает значение семафора с нулем.
    
- Если значение семафора больше нуля, операция down уменьшает его и просто возвращает управление. Если значение семафора равно нулю, процедура down не возвращает управление процессу, а процесс переводится в состояние ожидания.
    
- Все операции проверки значения семафора, его изменения и перевода процесса в состояние ожидания выполняются как единое и неделимое элементарное действие. Тем самым гарантируется, что после начала операции ни один процесс не получит доступа к семафору до окончания или блокирования операции.  

## Мьютексы

- Иногда используется упрощенная версия семафора, называемая мьютексом (mutex, сокращение от mutual exclusion – взаимное исключение).
    
- Мьютекс не способен считать, он может лишь управлять взаимным исключением доступа к совместно используемым ресурсам или кодам.
    
- Реализация мьютекса проста и эффективна, что делает использование мьютексов особенно полезным в случае потоков, действующих только в пространстве пользователя.
    
- Мьютекс – переменная, которая может находиться в одном из двух состояний: блокированном или неблокированном.
    
- Для описания мьютекса требуется всего один бит, хотя чаще используется целая переменная, у которой 0 означает неблокированное состояние, а все остальные значения соответствуют блокированному состоянию.
    
- Значение мьютекса устанавливается двумя процедурами. Если поток собирается войти в критическую область, он вызывает процедуру mutex_lock. Если мьютекс не заблокирован, запрос выполняется и вызывающий поток может попасть в критическую область.

## Мониторы 

- В 1974 году Хоар (Hoare) и Бринч Хансен (Brinch Hansen) предложили примитив синхронизации более высокого уровня, называемый монитором.

- Монитор - набор процедур, переменных и других структур данных, объединенных в особый модуль или пакет. Процессы могут вызывать процедуры монитора, но у процедур, объявленных вне монитора, нет прямого доступа к внутренним структурам данных монитора.

## Передача сообщений

Этот метод межпроцессного взаимодействия использует два примитива: send и receive, которые скорее являются системными вызовами, чем структурными компонентами языка. Например:

`send(destination, Smessage);`
`receive(source, &message);`

Первый запрос посылает сообщение заданному адресату, а второй получает сообщение от указанного источника. Если сообщения нет, второй запрос блокируется до поступления сообщения либо немедленно возвращает код ошибки.

## Барьеры

Последний из рассмотренных нами механизмов синхронизации предназначался скорее для групп процессов, нежели для ситуаций с двумя процессами. Некоторые приложения делятся на фазы, и существует правило, что процесс не может перейти в следующую фазу, пока к этому не готовы все остальные процессы. Этого можно добиться, разместив в конце каждой фазы барьер.

## Поведение процесса 

Практически все процессы чередуют периоды вычислений с операциями ввода-вывода. Обычно процессор некоторое время работает без остановки, затем происходит системный вызов на чтение из файла или запись в файл. После выполнения системного вызова процессор опять считает

## Когда планировать ?

Ключевым вопросом планирования является выбор момента принятия решений. Оказывается, существует множество ситуаций, в которых необходимо планирование.

Во-первых, когда создается новый процесс, необходимо решить, какой процесс запустить: родительский или дочерний.

Во-вторых, планирование необходимо, когда процесс завершает работу.

В-третьих, когда процесс блокируется на операции ввода-вывода, семафоре, или по какой-либо другой причине, необходимо выбрать и запустить другой процесс.

В-четвертых, необходимость Планирования может возникнуть при появлении прерывания ввода-вывода. Если прерывание пришло от устройства ввода-вывода, закончившего работу, можно запустить процесс, который был блокирован в ожидании этого события. 

## Когда планировать ? (2)

Алгоритмы планирования можно разделить на две категории согласно их поведению после прерываний.

Алгоритмы планирования без переключений, иногда называемого также неприоритетным планированием.

Алгоритмы планирования с переключениями, называемого также приоритетным планированием, выбирают процесс и позволяют ему работать некоторое максимально возможное фиксированное время. 

## Категории алгоритмов планирования

В различных средах требуются различные алгоритмы планирования. Это связано стем, что различные операционные системы и различные приложения ориентированы на разные задачи. Другими словами, то, для чего следует оптимизировать планировщик, различно в разных системах.

Можно выделить три среды:
1. Системы пакетной обработки данных.
2. Интерактивные системы.
3. Системы реального времени.


В системах пакетной обработки нет пользователей, сидящих за терминалами и ожидающих ответа. В таких системах приемлемы алгоритмы без переключений или с переключениями, но с большим временем, отводимым каждому процессу. Такой метод уменьшает количество переключений между процессами и улучшает эффективность.


В интерактивных системах необходимы алгоритмы планирования с переключениями, чтобы предотвратить захват процессора одним процессом. Даже если ни один процесс не захватывает процессор на неопределенно долгий срок намеренно, из-за ошибки в программе один процесс может заблокировать остальные. Для исключения подобных ситуаций используется планирование с переключениями.

В системах с ограничениями реального времени приоритетность, как это ни странно, не всегда обязательна, поскольку процессы знают, что их время ограничено, и быстро выполняют работу, а затем блокируются. Отличие от интерактивных систем в том, что в системах реального времени работают только программы, предназначенные для содействия конкретным приложениям. Интерактивные системы являются универсальными системами.


## Задачи алгоритмов планирования 

Все системы
- Равнодоступность — предоставление каждому процессу справедливой доли времени центрального процессора.
- Принуждение к определенной политике — наблюдение за выполнением установленной политики. 
- Баланс — поддержка загруженности всех составных частей системы.

Пакетные системы
+ Производительность — выполнение максимального количества заданий в час.
* Оборотное время — минимизация времени между представлением задачи и ее завершением.
- Использование центрального процессора — поддержка постоянной загруженности
процессора.

Интерактивные системы
- Время отклика — быстрый ответ на запросы.
- Пропорциональность — оправдание пользовательских надежд.

Системы реального времени
- Соблюдение предельных сроков — предотвращение потери данных.
- Предсказуемость — предотвращение ухудшения качества в мультимедийных системах.

# Планирование в системах пакетной обработки заданий «Первым пришел — первым ушел (FIFO)»


## «Первым пришел — первым ушел (FIFO)»

Алгоритм без переключений «первым пришел - первым обслужен» является, пожалуй, самым простым из алгоритмов планирования. Процессам предоставляется доступ к процессору в том порядке, в котором они его запрашивают. Чаще всего формируется единая очередь ждущих процессов. Как только появляется первая задача, она немедленно запускается и работает столько, сколько необходимо.

Остальные задачи ставятся в конец очереди. Когда текущий процесс блокируется, запускается следующий в очереди, а когда блокировка снимается, процесс попадает в конец очереди. Основным преимуществом этого алгоритма является то, что его легко понять и столь же легко программировать. Он справедлив в том же самом смысле, в каком справедливо распределение дефицитных билетов на концерт или соревнования среди всех желающих стоять в очереди с двух часов ночи. В этом алгоритме все процессы в состоянии готовности контролируются одним связным списком. Чтобы выбрать процесс для запуска, нужно всего лишь взять первый элемент списка и удалить его. Появление нового процесса приводит к помещению его в конец списка - что может быть проще?


## «Кратчайшая задача - первая»

Рассмотрим еще один алгоритм без переключений для систем пакетной обработки, предполагающий, что временные отрезки работы известны заранее.

Например, работники страховой компании могут довольно точно предсказать, сколько времени займет обработка Пакета из 1000 исков, поскольку они делают это каждый день. Если в очереди есть несколько одинаково важных задач, планировщик выбирает первой самую короткую задачу.

Есть четыре задачи: А, В, С и D, со временем выполнения 8, 4, 4 и 4 мин соответственно.

## Наименьшее оставшееся время выполнения

Версией предыдущего алгоритма с переключениями является алгоритм наименьшего оставшегося времени выполнения.

В соответствии с этим алгоритмом планировщик каждый раз выбирает процесс с наименьшим оставшимся временем выполнения.

В этом случае также необходимо заранее знать время выполнения задач.

Когда поступает новая задача, ее полное время выполнения сравнивается с оставшимся временем выполнения текущей задачи.

Если время выполнения новой задачи меньше, текущий процесс приостанавливается и управление передается новой задаче.

Эта схема позволяет быстро обслуживать короткие запросы.

## Трехуровневое планирование

Системы пакетной обработки позволяют реализовать трехуровневое планирование. По мере поступления в систему новые задачи сначала помещаются в очередь, хранящуюся на диске.

Впускной планировщик выбирает задание и передает его системе. Остальные задания остаются в очереди. Характерный алгоритм входного контроля может заключаться в выборе смеси из процессов, ограниченных возможностями процессора, и процессов, ограниченных возможностями устройств ввода-вывода.

Также возможен алгоритм, в котором устанавливается приоритет коротких задач перед длинными.

Впускной планировщик волен придержать некоторые задания во входной очереди, а пропустить задание, поступившее позже остальных.


## Циклическое планирование

Одним из наиболее старых, простых, справедливых и часто используемых является алгоритм циклического планирования. Каждому процессу предоставляется некоторый интервал времени процессора, так называемый квант времени.

Если к концу кванта времени процесс все еще работает, он прерывается, а управление передается другому процессу. Разумеется, если процесс блокируется или прекращает работу раньше, переход управления происходит в этот момент. Реализация циклического планирования проста. Планировщику нужно всего лишь поддерживать список процессов в состоянии готовности. Когда процесс исчерпал свой лимит времени, он отправляется в конец списка.


## Приоритетное планирование

Необходимость принимать во внимание подобные внешние факторы приводит к приоритетному планированию. Основная идея проста: каждому процессу присваивается приоритет, и управление передается готовому к работе процессу с самым высоким приоритетом.

Даже на персональном компьютере с одним пользователем может происходить несколько процессов, отдельные из которых являются более важными, чем другие. Демон, отвечающий за пересылку электронной почты в фоновом режиме, имеет более низкий приоритет, чем процесс, отображающий на экране видеофильм в реальном времени.

Приоритеты процессам могут присваиваться статически или динамически.


## Несколько очередей

Один из первых приоритетных планировщиков был реализован в системе CTSS

В результате было разработано решение с классами приоритетов. Процессам класса с высшим приоритетом выделялся один квант, процессам следующего класса - два кванта, следующего - четыре кванта и т. д. Когда процесс использовал все отведенное ему время, он перемещался на класс ниже. В качестве примера рассмотрим процесс, которому необходимо производить вычисления в течение 100 квантов. Вначале ему будет предоставлен один квант, затем он будет перекачан на диск. В следующий раз ему достанется 2 кванта, затем 4, 8,16, 32, 64, хотя из 64 он использует только 37.

## Самый короткий процесс — следующий»

Поскольку алгоритм «Кратчайшая задача — первая» минимизирует среднее оборотное время в системах пакетной обработки, хотелось бы использовать его и в интерактивных системах. Интерактивные процессы чаще всего следуют схеме «ожидание команды, исполнение команды, ожидание команды, исполнение команды...» Если рассматривать выполнение каждой команды как отдельную задачу, можно минимизировать общее среднее время отклика, запуская первой самую короткую задачу.

Один из методов основывается на оценке длины процесса, базирующейся на предыдущем поведении процесса. При этом запускается процесс, у которого оцененное время самое маленькое. Допустим, что предполагаемое время исполнения команды равно Т0 и предполагаемое время следующего запуска равно Т1. Можно улучшить оценку времени, взяв взвешенную сумму этих времен аТ0 + (1 - а)Т1.

Метод оценки следующего значения серии через взвешенное среднее предыдущего значения и предыдущей оценки часто называют старением. 

## Гарантированное планирование

Принципиально другим подходом к планированию является предоставление пользователям реальных обещаний и затем их выполнение. Вот одно обещание, которое легко произнести и легко выполнить: если вместе с вами процессором пользуются п пользователей, вам будет предоставлено 1/n мощности процессора.

В системе с одним пользователем и п запущенными процессорами каждому достанется 1/n циклов процессора. Чтобы выполнить это обещание, система должна отслеживать распределение процессора между процессами с момента создания каждого процесса. Затем система рассчитывает количество ресурсов процессора, на которое процесс имеет право, например время с момента создания, деленное на n. Теперь можно сосчитать отношение времени, предоставленного процессу, к времени, на которое он имеет право. Полученное значение 0.5 означает, что процессу выделили только половину положенного, а 2.0 означает, что процессу досталось в два раза больше, чем положено. Затем запускается процесс, у которого это отношение наименьшее, пока оно не станет больше, чем у его ближайшего соседа.

## Лотерейное планирование

Хотя идея обещаний пользователям и их выполнения хороша, но ее трудно реализовать. Для более простой реализации предсказуемых результатов используется другой алгоритм, называемый лотерейным планированием.

В основе алгоритма лежит раздача процессам лотерейных билетов на доступ к различным ресурсам, в том числе и к процессору. Когда планировщику необходимо принять решение, выбирается случайным образом лотерейный билет, и его обладатель получает доступ к ресурсу. Что касается доступа к процессору, «лотерея» может происходить 50 раз в секунду, и победитель получает 20 мс времени процессора.

## Планирование в системах реального времени

Системы реального времени делятся на жесткие системы реального времени, что означает наличие жестких сроков для каждой задачи (в них обязательно надо укладываться), и гибкие системы реального времени, в которых нарушения временного графика нежелательны, но допустимы. В обоих случаях реализуется разделение программы на несколько процессов, каждый из которых предсказуем. Эти процессы чаще всего бывают короткими и завершают свою работу в течение секунды. Когда появляется внешний сигнал, именно планировщик должен обеспечить соблюдение графика.

## Планирование в системах реального времени (2)

Внешние события, на которые система должна реагировать, можно разделить на:
-  периодические (возникающие через регулярные интервалы
времени);
* непериодические (возникающие непредсказуемо).

Возможно наличие нескольких периодических потоков событий, которые система должна обрабатывать. В зависимости от времени, затрачиваемого на обработку каждого из событий, может оказаться, что система не в состоянии своевременно обработать все события.

Если в систему поступает n1 периодических событий, событие с номером i поступает с периодом Pi на его обработку уходит Сi, секунд работы процессора, все потоки могут быть своевременно обработаны только при выполнении условия

## Угрозы безопасности

Объект ОС может подвергнуться следующим типичным атакам:
- сканированию файловой системы
- подбору пароля
- краже ключевой информации
- сборке мусора
- превышению полномочий
- программным закладкам
- жадным программам

## Сканирование файловой системы

Злоумышленник просматривает файловую систему компьютера и пытается прочесть (или скопировать) все файлы подряд. Рано или поздно обнаруживается хотя бы одна ошибка администратора. В результате злоумышленник получает доступ к информации, который должен быть ему запрещен.

## Подбор пароля

Существуют несколько методов подбора паролей пользователей:
1. тотальный перебор;
2. тотальный перебор, оптимизированный по статистике встречаемости символов или с помощью словарей;
3. подбор пароля с использованием знаний о пользователе (его имени, фамилии, даты рождения, номера телефона ит. д.).

## Кража ключевой информации

Злоумышленник может подсмотреть пароль, набираемый пользователем, или восстановить набираемый пользователем пароль по движениям его рук на клавиатуре. Носитель с ключевой информацией (смарт-карта, Touch Memory и т.д.) может быть просто украден.

## Сборка мусора

Во многих ОС информация, уничтоженная пользователем, не уничтожается физически, а помечается как уничтоженная (так называемый мусор). Злоумышленник восстанавливает эту информацию, просматривает ее и копирует интересующие его фрагменты.

## Превышение полномочий

Злоумышленник, используя ошибки в программном обеспечении ОС или политике безопасности, получает полномочия, превышающие те, которые ему предоставлены в соответствии с политикой безопасности. Обычно это достигается путем запуска программы от имени другого пользователя.

## Жадные программы

Жадные программы — это программы, преднамеренно захватывающие
значительную часть ресурсов компьютера, в результате чего другие программы не могут выполняться или выполняются крайне медленно. Запуск жадной программы может привести к краху ОС.


