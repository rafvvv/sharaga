#  15.01
#основные_понятия_и_функции_ОС

hardware (тех обесп) - процессор память монитор дисковые устройства
software (програмн обесп) - системное прикладное средства разработки 

| Пользователь |
| ---- |
| Прикладные программы |
| Системные программы |
| Операционная система |
| Техническое обеспечение |
#структура_вычислительной_системы

Прикладное ПО - к этому относится разнообразные банковские и прочие бизнес-программы, игры, текстовые процессоры и тд
Системное ПО - к этому относится программы сопутствующие функционированию и разработке прикладных программ.

ОС является частью системного ПО

#ОС_как_менеджер_ресурсов_обеспечивает:
- загрузку пользовательских программ в ОЗУ
- выполнение этих программ путём организации работы процессора
- работу с устройствами долговременной памяти, такими как магнитные диски ленты оптические диски и тд
- стандартный доступ к различным устройствам ввода/вывода (терминалы модемы печатающие устр-ва)
#основные_функции_ОС_как_защитника_полльзователей_и_програм :
- обеспечение сохранности инф на диске, т.е. защита от. удаления или повреждения чужих файлов
- защита от произвольного вмешательства в работу программ одних пользователей программ других пользователей
- пресечение попыток несанкционированного использования вычислительной сис
#уровни/виды_интерфейсов
1. пользовательский - предназначен для работы с готовыми приложениями
2. программный - интерфейс прикладного программирования, представляющий собой средства обращающиеся к возможностям ОС

- [ ] ОС - это комплекс программ, обесп возможность рационального исп оборудования и ПО удобным для пользователя образом 
- [ ] ОС - это система программ реализующая интерфейс между аппаратурой ЭВМ и пользователем
- [ ] ОС - это комплекс управляющих и обрабатывающих программ который выступает как интерфейс и как эффективного управления оборудования и ПО 

#эволюция_ОС
# 1-й период (1945-1955)
- ламповые машины
- нет разделения персонала
- нет ОС
- ввод программы с пульта или с колоды перфокарт
- отладка программы с пульта
- одновременное выполнение только одной программы
- появление прообразов первых компиляторов

# 2 период (1955-начало 60-х)
- компы на основе транзисторов
- снижение энергопотребления
- уменьшение размеров компов
- снижение стоимости их экслуатации и обслуживания

# 3.1 период (начало 60-х - 1980)
- компы на основе ИМС
- первые многозадачные пк
- рост  производительности процессоров
# 3.2 период
- магнитные диски
- мультипрограммирование
- защитные механизмы
# 3.3
- мультипрограммирование привело к изменению ОС
# 3.4
- элт дисплеи
- процессор переключается не только между операциями ввода/вывода

# 22.01
# 4 период (1980-е - наше время)
- Персональные компьютеры
- появление БИС
- удешевление и возрастание мощности
- пк стал бытовым прибором

#System_calls -интерфейс между ос и прикладной программой 
	- создают удаляют используют файлы и процессы
	перход задачи в превелегированный режим (kernel mode)
#hardwere_interputt - событие генерируемое внешним (по отношению к процессору) устройством

#Exception - возникает в результате выполнения программой недопустимой операции, доступак ресурсу при отсутствии необходимой привелегии или обращения к отсутствующей страницы памяти

#файл - часть пространства на носителе информации, имебщая имя

#файловая_система - скрывает особенности ввода-вывода и даёт программисту простую обстрактную модель файлов, независимую от устройств

# Операционные оболочки

	Операционная оболочка (operation shell) - комплекс программ, ориентированных наопределенную операционную систему предназначенный для облегчения диалога между пользователем и компьютером при выполнении определенных видов деятельности на компьютере.

	Оболочка ОС - интерпретатор команд операционной системы, обеспечивающий системы, интерфейс для взаимодействия пользователя с функциями системы.

![](https://github.com/rafvvv/Os_practic/blob/main/photos/photo_2024-01-22_12-58-27.jpg?raw=true)

![](https://github.com/rafvvv/Os_practic/blob/main/photos/photo_2024-01-22_13-03-24.jpg?raw=true)

![](https://github.com/rafvvv/Os_practic/blob/main/photos/photo_2024-01-22_13-09-19.jpg?raw=true)

# Виды вспомогательных модулей
- ﻿﻿Утилиты - программы, решающие отдельные задачи управления и сопровождения компьютерной системы (сжатие дисков, их проверка, дефрагментация; архивирование, сбор статистики и т.д.);
- ﻿﻿Системные обрабатывающие программы (загрузчики, отладчики, текстовые или графические редакторы);
- ﻿﻿Библиотеки процедур различного назначения для разработки приложений (математические функции, функции ввода-вывода и т.д.);
- ﻿﻿Программы, предоставляющие дополнительные услуги (калькулятор, некоторые игры).

![](https://github.com/rafvvv/Os_practic/blob/main/photos/photo_2024-01-22_13-22-00.jpg?raw=true)

# 29.01
## Монолитное ядро +/-
| плюсы | минусы |
| ---- | ---- |
|  Производительность - в виду того, что количество переключений из контекста режима пользователя в режим ядра сведено к минимуму. | Неустойчивость к сбоям - так как все базовые элементы и их работа выполняются в режиме ядра, и если хотя бы в одном модуле или блоке ядра произойдет какой-либо сбой, то ему будет подвержена вся ОС (все ядро), вариантов других нет, закончится все - перезапуском ОС.\| |
## Архитектура ОС, основанная на привилегированном ядре и приложениях пользовательского режима является КЛАССИЧЕСКОЙ = МНОГОСЛОЙНЫЙ ПОДХОД
- При таком подходе разработка системы осуществляется сверху вниз, от целей системы к их реализации.
- ﻿﻿Сначала определяются функции слоев и межслойные интерфейсы, задающие общую структуру системы, а затем разрабатываются модули внутри слоев.
![](https://github.com/rafvvv/Os_practic/blob/main/photos/photo_2_2024-02-19_12-51-18.jpg?raw=true)

## Многослойная структура ядра ОС
- Многослойный подход применим и к структуре ядра как сложного многофункционального комплекса
![](https://github.com/rafvvv/Os_practic/blob/main/photos/photo_3_2024-02-19_12-51-18.jpg?raw=true)

## РЕЗЮМЕ Многослойной / классической / многоуровневой архитектуры
- Все компоненты ОС разделяются на модули, выполняющие основные функции ОС (ядро), и модули, выполняющие вспомогательные функции ОС.
- Вспомогательные модули оформляются либо в виде приложений, либо в виде библиотек процедур и функций.
- Вспомогательные модули являются транзитными (загружаются в оперативную память только на время вышолнения). Модули ядра - резидентными (постоянно находящиеся в оперативной памяти).
- Устойчивость ОС повышается путем выполнения функций ядра в привилегированном режиме, а вспомогательных модулей ОС и пользовательских приложений - в пользовательском.
#### Многослойная классическая многоуровневая архитектура ОС 
#### ___не лишена своих проблем.___
1. Дело в том, что значительные изменения одного из уровней могут иметь трудно предвидимое влияние на смежные уровни.
2. Кроме того, многочисленные взаимодействия между соседними уровнями усложняют обеспечение безопасности.
Поэтому, как альтернатива классическому варианту архитектуры ОС, часто используется __МИКРОЯДЕРНАЯ__ архитектура ОС.

# МИКРОЯДРО / МИКРОЯДЕРНАЯ архитектура 
| Микроядро | • ядро, содержащее только самые необходимые функции. |
| ---- | ---- |
| Идея: | • минимизировать само ядро, вынести как можно функциональности в режим пользователя (т.е. исполнять эту функциональность в виде обычных процессов). |
| Многие сервисы становятся пользовательскими процессами: | • Драйверы устройств,<br><br>• Файловые системы,<br><br>• Менеджер виртуальной памяти,<br><br>• Оконные системы графического интерфейса пользователя,<br><br>• Службы безопасности<br><br>• Данный подход популяризован ядром МАСН («МАК»)<br><br>• На основе МАСН сделаны, среди прочих, Мас<br><br>OSX (комп.Apple), GNUHurd. |
# Суть МИКРОЯДЕРНОЙ архитектуры
- В привилегированном режиме остается работать только очень небольшая часть ОС, называемая микроядром.
- ﻿﻿Микроядро защищено от остальных частей ОС и приложений. В его состав входят машинно-зависимые модули, а также модули, выполняющие базовые механизмы обычного ядра.
- ﻿﻿Все остальные более высокоуровневые функции ядра оформляются как модули, работающие в пользовательском режиме. Так, менеджеры ресурсов, являющиеся неотьемлемой частью обычного ядра, становятся "периферийными" модулями, работающими в пользовательском режиме.
- ﻿﻿Таким образом, в архитектуре с микроядром традиционное расположение уровней по вертикали заменяется горизонтальным.
- ﻿﻿Между собой они взаимодействуют как равноправные партнеры с помощью обмена сообщениями, которые передаются через микроядро.
![](https://github.com/rafvvv/Os_practic/blob/main/photos/photo_6_2024-02-19_12-51-18.jpg?raw=true)

#
# Многослойная структура ядра ОС
- Средства аппаратной поддержки ОС - аппаратные средства, прямо участвующие в организации вычислительных процессов: средства поддержки привилегированного режима, система прерываний, переключение контекстов процессов, трансляция адресов, защита памяти и т.п.
- Машино-зависимые модули - программные модули, в которых отображается специфика аппаратной платформы компьютера. В идеале этот слой полностью экранирует* вышележащие слои от особенностей аппаратуры, т.е. позволяет делать модули вышележащих слоев машинно-независимыми.
- ﻿﻿На уровне HAL работа с устройством определенного типа (накопитель, видеоплата, мышь и т.п.) всегда описывается при помощи одного и того же заранее определенного набора функций. В случае, если устройство имеет иной набор функций (например, устаревший 3d-ускоритель может не поддерживать многих современных функций), драйвер обязан эмулировать* стандартные функции с тем, чтобы ОС могла не заботиться о том, какое конкретно устройство установлено.

>﻿﻿Экранировать - предохранять от посторонних воздействий
> ﻿﻿Эмуляция - один из способов электронного архивирования устаревающих вычислительных систем.
- Базовые механизмы ядра. Модули этого слоя не принимают решений о распределении ресурсов, а только отрабатывают принятые на более высоком уровне решения. Выполняются наиболее примитивные операции ядра: программное переключение контекстов процессов, перемещение страниц между памятью и диском, диспетчеризация прерываний и т.п.
- ﻿﻿Менеджеры ресурсов. Модули этого уровня реализуют управление основными ресурсами системы. Группировка модулей в менеджеры обычно осуществляется по функциям основных подсистем ОС: выделяются менеджеры процессов, ввода-вывода и файловой системы (могут быть объединены), оперативной памяти.
- ﻿﻿Интерфейс системных вызовов. Взаимодействует непосредственно с приложениями и системными утилитами, образуя прикладной программный интерфейс ОС (API).

---
Загрузчик операционной системы - системное ПО, обеспечивающее загрузку операционной системы непосредственно после включения компьютера.

- ﻿﻿обеспечивает необходимые средства для диалога с пользователем компьютера (например, загрузчик позволяет выбрать ОС для загрузки);
- ﻿﻿приводит аппаратуру компьютера в состояние, необходимое для старта ядра ОС;
- ﻿﻿загружает ядро ОС в ОЗУ;
- ﻿﻿формирует параметры, передаваемые ядру ОС (например, ядру Linux передаются параметры, указывающие способ подключения корневой файловой системы);
- ﻿﻿передаёт управление ядру ОС. 
 
Базовая система ввода-вывода - набор программных средств, обеспечивающих взаимодействие ОС и приложений с аппаратными средствами. Обычно базовая система ввода-вывода представляет собой набор - драйверов.

Командный интерпретатор - необязательная, но присутствующая в большинстве операционных систем часть, которая обеспечивает управление системой посредством ввода текстовых команд.
Сервисное программное обеспечение - пакет приложений, включённый в состав операционной системы, реализующий множество полезных функций.

--- 
# Экзоядро ОС
Такое ядро ОС, которое предоставляет лишь функции взаимодействия процессов, безопасное выделение и распределение ресурсов. Доступ к устройствам на уровне контроллеров позволяет решать задачи, которые нехарактерны для универсальной ОС.

---
# Наноядро ОС
Такое ядро выполняет только единственную задачу-обработку аппаратных прерываний, образуемых устройствами ПК. После обработки наноядро посылает данные о результатах обработки далее идущему в цепи программному обеспечения при помощи той же системы прерываний.
Примером является KeyKOS - самая первая ОС на наноядре. Первая версия вышла ещё в 1983-м году.

---
# Гибридное ядро ОС
Модификация микроядер, позволяющая для ускорения работы впускать несущественные части в пространство ядра. На архитектуре гибкого ядра построены последние операционные системы от Windows, в том числе и Windows 7-10.

---
![](https://github.com/rafvvv/Os_practic/blob/main/photos/photo_14_2024-02-19_12-51-18.jpg?raw=true)

---
![](https://github.com/rafvvv/Os_practic/blob/main/photos/photo_15_2024-02-19_12-51-18.jpg?raw=true)

---
![](https://github.com/rafvvv/Os_practic/blob/main/photos/photo_16_2024-02-19_12-51-18.jpg?raw=true)

---
![](https://github.com/rafvvv/Os_practic/blob/main/photos/photo_17_2024-02-19_12-51-18.jpg?raw=true)

---
# 05.02
# Методы распределения памяти
Все алгоритмы распределения памяти разделены на два класса:
- ﻿﻿Алгоритмы, в которых используется перемещение сегментов процессов между оперативной памятью и диском;
- ﻿﻿Алгоритмы, в которых внешняя память не привлекается.

Алгоритмы, в которых внешняя память не привлекается:
- ﻿﻿Распределение памяти фиксированными разделами;
- ﻿﻿Распределение памяти динамическими разделами;
- ﻿﻿Распределение памяти перемещаемыми
![](https://github.com/rafvvv/Os_practic/blob/main/photos/photo_3_2024-02-19_12-49-43.jpg?raw=true)

#  Распределение памяти динамическими разделами
- В этом случае память машины не делится заранее на разделы.
- ﻿﻿Сначала вся память, отводимая для приложений, свободна.
- ﻿﻿Каждому вновь поступающему на выполнение приложению на этапе создания процесса выделяется вся необходимая ему память (если достаточный объем памяти отсутствует, то приложение не принимается на выполнение и процесс для него не создается).
- ﻿﻿После завершения процесса память освобождается, и на это место может быть загружен другой процесс.
![](https://github.com/rafvvv/Os_practic/blob/main/photos/photo_5_2024-02-19_12-49-43.jpg?raw=true)

# Распределение памяти перемещаемыми разделами
- ﻿﻿Одним из методов борьбы с фрагментацией является перемещение всех занятых участков в сторону старших или младших адресов, так, чтобы вся свободная память образовала единую свободную область.
- ﻿﻿В дополнение к функциям, которые выполняет ОС при распределении памяти динамическими разделами в данном случае она должна еще время от времени копировать содержимое разделов из одного места памяти в другое, корректируя таблицы свободных и занятых областей - процедура называется сжатием.
![](https://github.com/rafvvv/Os_practic/blob/main/photos/photo_7_2024-02-19_12-49-43.jpg?raw=true)

---
Для преодоления перегрузки памяти были выработаны два основных подхода.
- ﻿﻿1. Самый простой из них, называемый свопингом, заключается в размещении в памяти всего процесса целиком, в запуске его на некоторое время, а затем в сбросе его на диск. Бездействующие процессы большую часть времени хранятся на диске и в нерабочем состоянии не занимают пространство оперативной памяти.
- ﻿﻿2. Второй подход называется виртуальной памятью, он позволяет программам запускаться даже в том случае, если они находятся в оперативной памяти лишь частично.

# Виртуальная память
Виртуальная память - это подход к управлению памятью компьютером, который скрывает физическую память (в различных формах, таких как: оперативная память или жесткие диски) за единым интерфейсом, позволяя создавать программы, которые работают с ними как с единым непрерывным массивом памяти с произвольным доступом.
![](https://github.com/rafvvv/Os_practic/blob/main/photos/photo_9_2024-02-19_12-49-43.jpg?raw=true)

- Виртуальная память - метод управления памятью, которая реализуется с использованием аппаратного и программного обеспечения компьютера.
- ﻿﻿Она отображает используемые программами виртуальные адреса в физические адреса в памяти компьютера.
- ﻿﻿Основная память представляется в виде непрерывного адресного пространства или набора смежных непрерывных сегментов.

К основным преимуществам виртуальной памяти относят:
- ﻿﻿Избавление программиста от необходимости управлять общим пространством памяти,
- ﻿﻿Повышение безопасность использования программ за счет выделения памяти,
- ﻿﻿Возможность иметь в распоряжении больше памяти, чем это может быть физически доступно на компьютере.

Виртуальная память делает программирование приложений проще:
- ﻿﻿Скрывая фрагментацию физической памяти;
- ﻿﻿Устраняя необходимость в программе для обработки наложений в явном виде;
- ﻿﻿Когда каждый процесс запускается в своем собственном выделенном адресном пространстве, нет необходимости переместить код программы или получить доступ к памяти с относительной адресацией.

# Страничное распределение
- При таком способе все фрагменты программы, на которые она разбивается (кроме последней части) получаются одинаковыми.
- ﻿﻿Одинаковыми должны быть и единицы памяти предоставляемые для размещения фрагментов программы.

![](https://github.com/rafvvv/Os_practic/blob/main/photos/photo_14_2024-02-19_12-49-43.jpg?raw=true)
- Когда программа ссылается на часть своего адресного пространства, находящегося в физической памяти, то операция выполняется сразу.
# Страничная организация памяти
С точки зрения программиста:
- ﻿﻿Процессам виртуальное адресное пространство представляется непрерывным, от байта 0 до байта N
- ﻿﻿N зависит от аппаратной поддержки (например 32бит. - адр.пространство 4Гб), делится соответственно.
- ﻿﻿В реальности виртуальные страницы распределены по страницам физической памяти далеко не непрерывно и не один к одному.
- ﻿﻿Это два разных мира - физические страницы и виртуальные страницы.

# 12.02
![](https://github.com/rafvvv/Os_practic/blob/main/photos/photo_1_2024-02-19_12-47-42.jpg?raw=true)

- Страничный способ организации виртуальной памяти - способ разрывного размещения задач в памяти, при котором все фрагменты задачи имеют одинаковый размер, кратный степени двойки (для использования операции конкатенации).

___Виртуальный адрес состоит из двух полей:___
- ﻿﻿Указатель на часть программы (с которой идет работы) для определения местоположения этой части;
- ﻿﻿Относительный адрес нужного фрагмента памяти (по отношению к найденному адресу).

# Трансляция адресов
Трансляция виртуального адреса:
- ﻿﻿Виртуальный адрес состоит из двух частей: номер виртуальной страницы (VPN) и смещение внутри страницы
- ﻿﻿Номер виртуальной страницы (VPN- virtual page number) это индекс в таблице страниц (Pagetable)
- ﻿﻿Запись в таблице страниц (РТЕ - page table entry) содержит номер фрейма (PFN -page frame number)
- ﻿﻿Фрейм - это страница физической памяти.
- ﻿﻿Номер фрейма (PFN) - это номер физической страницы.
- Смысл таблицы страниц - одна запись в таблице страниц (РТЕ) на одну страницу виртуального адресного пространства (VPN), отображает VPN на PFN. Какая виртуальная страница соответствует какому фрейму физической памяти.
![](https://github.com/rafvvv/Os_practic/blob/main/photos/photo_6_2024-02-19_12-47-42.jpg?raw=true)

# Таблица страниц
Запись в таблице - дескриптор страницы
- ﻿﻿Номер физической страницы, в которую загружена данная виртуальная страница;
- ﻿﻿Признак присутствия = 1, если виртуальная страница находится в ОП;
- ﻿﻿Признак модификации страницы → 1, когда производится запись по адресу, относящемуся к данной странице;
- ﻿﻿Признак обращения (бит доступа) → 1, при каждом обращении по адресу, относящемуся к данной странице;

# Страничное прерывание
- ﻿﻿Номер виртуальной страницы → определяется нужный элемент таблицы страниц → извлечение информации о станице (в том числе адрес в ОП)
- ﻿﻿Анализ признака присутствия, если страница в ОП есть → преобразование адреса (ВА - ФА), если страницы нет, то страничное прерывание (действия)
![](https://github.com/rafvvv/Os_practic/blob/main/photos/photo_9_2024-02-19_12-47-42.jpg?raw=true)

Это происходит в два этапа:
- ﻿﻿Посредством системы программирования;
- ﻿﻿Посредством операционной системы (с помощью специальных программных модулей управления памятью и использования соответствующих аппаратных средств вычислительной системы).
![](https://github.com/rafvvv/Os_practic/blob/main/photos/photo_11_2024-02-19_12-47-42.jpg?raw=true)

- Страничная память — способ организации виртуальной памяти, при котором единицей отображения виртуальных адресов на физические является фрагмент постоянного размера — страница.
- ﻿﻿При использовании страничной модели вся виртуальная память делится на N страниц таким образом, что часть виртуального адреса интерпретируется как номер страницы, а часть — как смещение внутри страницы.
![](https://github.com/rafvvv/Os_practic/blob/main/photos/photo_13_2024-02-19_12-47-42.jpg?raw=true)

# Сегментное распределение - вывод
- ﻿﻿Сегментная организация виртуальной памяти реализует следующий механизм: вся память делиться на сегменты фиксированной или произвольной длины, каждый из которых характеризуется своим начальным адресом.
- ﻿﻿Виртуальный адрес в такой системе состоит из 2-х компонент: базы сегмента, к которому мы хотим обратиться, и смещения внутри сегмента.
# Странично-сегментное распределение
- ﻿﻿Данный метод представляет собой комбинацию страничного и сегментного распределения памяти и, вследствие этого, сочетает в себе достоинства обоих ПоДХодоВ.
- ﻿﻿Виртуальное пространство процесса делится на сегменты, а каждый сегмент в свою очередь делится на виртуальные страницы, которые нумеруются в пределах сегмента.
- ﻿﻿Оперативная память делится на физические страницы.

# 19.02

---

# Методы распределения памяти без использования внешней памяти:
- ﻿﻿Распределение памяти фиксированными разделами.
- ﻿﻿Распределение памяти разделами переменной величины.
- ﻿﻿Перемещаемые разделы.
__Если достаточный объем памяти отсутствует, то задача не принимается на выполнение и стоит в очереди. После завершения задачи память освобождается, и на это место может быть загружена другая задача.__
![](https://github.com/rafvvv/Os_practic/blob/main/photos/photo_3_2024-02-19_13-48-53.jpg?raw=true)

![](https://github.com/rafvvv/Os_practic/blob/main/photos/photo_4_2024-02-19_13-48-53.jpg?raw=true)


---
![](https://github.com/rafvvv/Os_practic/blob/main/photos/photo_5_2024-02-19_13-48-53.jpg?raw=true)

# Введение в Docker
![](https://github.com/rafvvv/Os_practic/blob/main/photos/photo_6_2024-02-19_13-48-53.jpg?raw=true)

![](https://github.com/rafvvv/Os_practic/blob/main/photos/photo_7_2024-02-19_13-48-53.jpg?raw=true)

# Для чего нужен (или плюсы):
1. ﻿﻿﻿Изолированный запуск приложений в контейнерах.
2. ﻿﻿﻿Упрощение разработки, тестирования и деплоя приложении.
3. ﻿﻿﻿Отсутствие необходимости конфигурировать среду для запуска - она поставляется вместе с приложением - в контейнере.
4. ﻿﻿﻿Упрощает масштабируемость приложений и управление их работой с помощью систем оркестрации контейнеров.
## Из чего состоит?
1. ﻿﻿﻿Образы
2. ﻿﻿﻿Контейнеры
3. ﻿﻿﻿Volumes
4. ﻿﻿﻿Networks
![](https://github.com/rafvvv/Os_practic/blob/main/photos/photo_9_2024-02-19_13-48-53.jpg?raw=true)

## Образ
- Read-only шаблон с набором инструкций, предназначенных для создания контейнера
- ﻿﻿Образ состоит из неизменяемых слоев, каждый из которых добавляет/удаляет/изменяет файлы из предыдущего слоя.
- ﻿﻿Неизменяемость слоев позволяет их использовать совместно в разных образах.
![](https://github.com/rafvvv/Os_practic/blob/main/photos/photo_10_2024-02-19_13-48-53.jpg?raw=true)

# Что делает docker при запуске образа?

```
$ docker run --rm -p 8888:80 nginx
```

- ﻿﻿скачивает образ
- ﻿﻿создает контейнер
- ﻿﻿инициализирует файловую систему и монтирует read-only образ
- ﻿﻿инициализирует сеть/ мост
- ﻿﻿запускает указанный процесс
- ﻿﻿обрабатывает и выдает вывод приложения
![](https://github.com/rafvvv/Os_practic/blob/main/photos/photo_12_2024-02-19_13-48-53.jpg?raw=true)

__При сегментно-страничном способе организации виртуальной памяти программа разбивается на логически законченные части - сегменты, виртуальный адрес содержит указание на номер соответствующего сегмента.__
![](https://github.com/rafvvv/Os_practic/blob/main/photos/photo_14_2024-02-19_13-48-53.jpg?raw=true)

# Виртуальный адрес можно представить состоящим из двух полей:
- ﻿указатель на часть программы (с которой идет работы) для определения местоположения этой части;
- ﻿относительный адрес нужной ячейки памяти (по отношению к найденному адресу).
# Подсистема управления памятью в этом случае выполняет следующие задачи:
- ﻿﻿сравнивая размер программы, поступившей на выполнение, и свободных разделов, выбирает подходящий раздел,
- ﻿﻿осуществляет загрузку программы и настройку адресов.

# При распределение памяти разделами переменной величины память машины не делится заранее на разделы. Сначала вся память свободна. Каждой вновь поступающей задаче выделяется необходимая ей память.
__Виртуальное адресное пространство зависит от:__
- ﻿﻿Архитектуры процессора;
- ﻿﻿Системы программирования.
__Виртуальное адресное пространство не зависит от:__
- Объема реальной физической памяти, установленной в компьютере.
#  Все методы управления памятью могут быть разделены на два класса:
- ﻿﻿методы, которые используют перемещение процессов между оперативной памятью и диском,
- ﻿﻿методы, которые не делают этого.
# Методы распределения памяти без использования внешней памяти:

- ﻿﻿Распределение памяти фиксированными разделами.
- ﻿﻿Распределение памяти разделами переменной величины.
- ﻿﻿Перемещаемые разделы.

---
# 26.02

![](https://github.com/rafvvv/Os_practic/blob/main/photos/photo_2024-02-26_12-25-44.jpg?raw=true)

1 FROM ruby: 2.7-buster

2

3 RUN apt-get update

4

5 ENV SRC_PATH / app

6 RUN mkdir -p $SRC_PATH

7 WORKDIR $SRC_PATH

8

9 ADD • •

10

11 CMD ["ruby", "test. rb"]

![](https://github.com/rafvvv/Os_practic/blob/main/photos/photo_2024-02-26_12-28-59.jpg?raw=true)

---

docker-compose
- инструментальное средство, предназначенное для решения задач, связанных с развёртыванием проектов.

![](https://github.com/rafvvv/Os_practic/blob/main/photos/photo_2024-02-26_12-29-09.jpg?raw=true)

# Установка docker-compose (Linux)
https://docs.docker.com/compose/install/
Скачиваем docker-compose сразу в папку /usr/local/bin
$ sudo curl -L
"https://github.com/docker/compose/releases/download/1.25.3/doc ker-compose-$(uname -s)-$(uname -m)" -0 /usr/local/bin/docker-compose
 Устанавливаем разрешение на запуск
$ sudo chmod +x/usr/local/bin/docker-compose
Проверяем
$ docker-compose --version

![](https://github.com/rafvvv/Os_practic/blob/main/photos/photo_2024-02-26_12-33-04.jpg?raw=true)

![](https://github.com/rafvvv/Os_practic/blob/main/photos/photo_2024-02-26_12-44-24.jpg?raw=true)

![](https://github.com/rafvvv/Os_practic/blob/main/photos/photo_2024-02-26_12-49-58.jpg?raw=true)

![](https://github.com/rafvvv/Os_practic/blob/main/photos/photo_2024-02-26_12-57-40.jpg?raw=true)

![](https://github.com/rafvvv/Os_practic/blob/main/photos/photo_2024-02-26_12-57-45.jpg?raw=true)

![](https://github.com/rafvvv/Os_practic/blob/main/photos/photo_2024-02-26_12-59-50.jpg?raw=true)


---
# основные команды docker compose
1. up
2. ps
3. down
4. build
5. run
6. logs


---

![](https://github.com/rafvvv/Os_practic/blob/main/photos/photo_2024-02-26_13-15-23.jpg?raw=true)

Классификация угроз по цели:
- ﻿﻿Несанкционированное чтение информации
- ﻿﻿Несанкционированное изменение информации
- ﻿﻿Несанкционированное уничтожение информации
- ﻿﻿Полное или частичное уничтожение ОС (от кратковременного вывода из строя программных модулей до физического стирания их с диска системных файлов)

Классификация угроз по принципу воздействия на ОС:

- ﻿﻿Использование известных (легальных каналов получения информации, например, несанкционированного чтения пользователя которому доступ ограничен
- ﻿﻿Использование скрытых каналов получения информации, например, угроза использования злоумышленником недокументированных возможностей ОС
- ﻿﻿Создание новых каналов получения информации с помощью программных закладок

Классификация угроз по принципу воздействия на ОС

| Активное воздействие <br>несанкционированные<br>действия злоумышленника в системе | Пассивное воздействие<br> несанкционированные наблюдения злоумышленника за процессами происходящими в системе |
| ---- | ---- |
![](https://github.com/rafvvv/Os_practic/blob/main/photos/photo_2024-02-26_13-21-50.jpg?raw=true)

Классификация угроз по типу используемой злоумышленником слабости защиты:
- Неадекватная политика безопасности, в том числе ошибки администратора системы
- Ошибки и недокументированные возможности программного обеспечения ОС, в том числе и так называемые люки - случайно или преднамеренно встроенные в систему «служебные входы» , позволяющие обходить систему

__Процесс__
Процесс - абстрактное понятие, описывающие работу программы.
В современных ОС многозадачность реализована за счет предоставления пользовательской программе процессора на несколько миллисекунд. При условии чередования использования процессора между программами.

__Модель процесса__
Все ПО исполняемое на компьютере, а иногда и операционная система, организовано в виде последовательных процессов.
Процессом является выполняемая программа, включая:
- ﻿﻿текущие значения счетчиков команд
- ﻿﻿текущие значения регистров
- ﻿﻿текущие значения переменных

# Классификация угроз по цели:

- Несанкционированное чтение информации
    
- Несанкционированное изменение информации
    
- Несанкционированное уничтожение информации
    
- Полное или частичное уничтожение ОС (от кратковременного вывода из строя программных модулей до физического стирания их с диска системных файлов)

# Классификация угроз по принципу воздействия на ОС:

- Использование известных (легальных) каналов получения информации, например, несанкционированного чтения пользователя которому доступ ограничен
    
- Использование скрытых каналов получения информации, например, угроза использования злоумышленником недокументированных возможностей ОС
    
- Создание новых каналов получения информации с помощью программных закладок

Классификация угроз по принципу воздействия на ОС:
1. Активное воздействие – несанкционированные действия злоумышленника в системе.
2. Пассивное воздействие – несанкционированные наблюдения злоумышленника за процессами происходящими в системе.

Разновидности кибератак:
1. Массовые угрозы (90%)
2. Более сложные атаки (9.9%)
3. Самые сложные в техническом плане атаки (0.1%)

Классификация угроз по типу используемой злоумышленником слабости защиты:
- Неадекватная политика безопасности, в том числе ошибки администратора системы
- Ошибки и недокументированные возможности программного обеспечения ОС, в том числе и так называемые люки – случайно или преднамеренно встроенные в систему “служебные входы”, позволяющие обходить систему.

**Процесс** – абстрактное понятие, описывающие работу программы.

В современных ОС многозадачность реализована за счёт предоставления пользовательской программе процессора на несколько миллисекунд. При условии чередования использования процессора между программами.

## Модель процесса

Все ПО, исполняемое на ПК, а иногда и ОС, организовано в виде последовательных процессов.

Процессом является выполняемая программа, включая:
- Текущие значения счетчиков команд
- Текущие значения регистров
- Текущие значения переменных

В отдельно взятый момент времени активна только одна программа.

Центральный процессор переключается между процессами, следовательно, скорость вычислений процесса всегда будет разной.

Процессы не должны программироваться с жестко заданным временем выполнения.

Планирование процессов.

Программа и процесс понятия схожие, но разные!

Если программа запущенная дважды, то ею заняты два процесса.

## Создание процесса

В универсальных системах определённые способы создания и прекращения процессов по мере необходимости.

Способы создания процессов:
1. Инициализация системы
2. Выполнение работающим процессом системного запроса на создание процесса
3. Запрос пользователя на создание процесса
4. Инициализация пакетного задания

При загрузке ОС создается несколько процессов:
- Процессы, обеспечивающие взаимодействие с пользователями и выполнение заданий, являются высокоприоритетными процессами.
- Процессы, не связанные с конкретными пользователями, но выполняющими ряд специфических функций, являются фоновыми процессами (демонами)

Новый процесс формируется на основании системного запроса от текущего процесса.

В роли текущего процесса может выступать:
- Процесс, запущенный пользователем.
- Системный процесс.
- Процесс, инициализированный устройством ввода.
- Процесс, управляющий пакетами.

Завершение процесса:
1. Обычный выход (преднамеренно).
2. Выход по ошибке (преднамеренно).
3. Выход по неисправимой ошибке (непреднамеренно)
4. Уничтожение другим процессом (непреднамеренно)

Состояние процессов:
1. Работающий
2. Готовый к работе
3. Заблокированный

- Процесс блокируется, ожидая входных данных.
    
- Планировщик выбирает другой процесс
    
- Планировщик выбирает этот процесс
    
- Доступные входные данные

Реализация процессов

| Управление процессом                  | Управление памятью             | Управление файлами |
| ------------------------------------- | ------------------------------ | ------------------ |
| Регистры                              | Указатель на текстовый сегмент | Корневой каталог   |
| Счетчик команд                        | Указатель на сегмент данных    | Рабочий каталог    |
| Слово состояния программы             | Указатель на сегмент диска     | Дескрипторы файла  |
| Указатель стека                       | Идентификатор пользователя     |                    |
| Состояние процесса                    | Идентификатор группы           |                    |
| Приоритет                             |                                |                    |
| Параметры планирования                |                                |                    |
| Идентификатор процесса                |                                |                    |
| Родительский процесс                  |                                |                    |
| Группа процесса                       |                                |                    |
| Сигналы                               |                                |                    |
| Время начала процесса                 |                                |                    |
| Использованное процессорное время     |                                |                    |
| Процессорное время дочернего процесса |                                |                    |
| Время следующего аварийного сигнала   |                                |                    |
Реализация процессов (схема обработки прерываний)
1. Аппаратное обеспечение сохраняет в стеке счетчик команд и т.п
2. Аппаратное обеспечение загружает новый счетчик команд из вектора пребываний
3. Процедура на ассемблере сохраняет регистры
4. Процедура на ассемблере устанавливает новый стек
5. Запускается программа обработки прерываний на С
6. Планировщик выбирает следующий процесс
7. Программа на С передает управление процедуре на ассемблере
8. Процедура на ассемблере запускает новый процесс

## Использование потоков. Пример. WEB-сервер.

Способ организации web-сервера:
1. Один поток, называемый диспетчером, считывает приходящие по сети запросы.
2. После этого он находит свободный (то есть блокированный) рабочий поток и передаёт ему запрос, скажем, записывая указатель сообщения в специальное слово, связанное с каждым потоком.
3. Затем диспетчер активизирует ждущий поток, переводя его из состояния блокировки в состояние готовности.

## Модель потока. Группировка ресурсов.

Процесс можно рассматривать как способ объединения родственных ресурсов в 1 группу.

У процесса есть адресное пространство, содержащее текст программы и данные, а также другие ресурсы.

Ресурсами являются: открытые файлы, дочерние процессы, необработанные аварийные сообщения, обработчики сигналов и м.д.

Гораздо проще управлять ресурсами, объединив их в форме процесса.

## Модель потока. Выполнение программы.

Процесс можно рассматривать как поток исполняемых команд или просто поток.

Компоненты потока:

Счетчик команд, отслеживающий порядок выполнения действий.

Регистры, в которых хранятся текущие переменные.

Стек, содержащий протокол выполнения процесса.

## Отличия потока от процесса.

Процессы используется для группирования ресурсов, а потоки являются субъектами, поочерёдно исполняющимися на ЦП.

Различные потоки в одном процессе не так зависимы, как различные процессы. У всех потоков одно и то же адресное пространство, что означает совместное использование глобальных переменных.

Любой поток имеет доступ к любому адресу ячейки памяти в адресном пространстве процесса, один поток может считывать, записывать или ддаже стирать информацию из стека другого потока.

Защиты не существует, поскольку: это невозможно и – это ненужно. В отличие от различных процессов, которые инициированы различными пользователями, один процесс всегда запущен 1 пользователем, и потоки созданы, чтобы работать совместно.

| Элементы процесса                    | Элементы потока |
| ------------------------------------ | --------------- |
| Адресное пространство                | Счетчик команд  |
| Глобальные переменные                | Регистры        |
| Открытые файлы                       | Стек            |
| Дочерние процессы                    | Состояние       |
| Необработанные аварийные сигналы     |                 |
| Сигналы и их обработчики             |                 |
| Информация об использовании ресурсов |                 |
 
## Потоки в POSIX

IEEE standart 1003.1c – стандарт создания переносимых многопоточных программ

Пакет Pthreads, реализует работу с потоками, поддерживается большинством UNIX-систем.

В стандарте определено более 60 вызовов функций.

Все потоки Pthreads имеют опред.свойства.

У каждого потока есть свой ID, набор регистров, атрибутов. В атрибуты входят размер стека, параметры планирования и др.элементы, необходимые для использования потока.

Вызовы, связанные с потоком и их описание

Pthread_create – создание потока

Pthread_exit – завершение вызвавшего потока

Pthread_join – ожидание выхода из указанного потока

Pthread_vield - освобождение ЦП, позволяющее выполняться другому потоку

Pthread_attr_init – создание и инициализация структуры атрибутов потока

Pthread_attr_destroy – удаление структуры атрибутов потока

Есть 2 основных способа реализации пакета потоков: в пространстве пользователя и ядре.

## Активация планировщика

Цель активации планировщика заключается в имитации функциональных возможностей потоков на уровне ядра, но при лучшей производительности и более высокой гибкости, свойственной пакетам потоков, реализуемых в пользовательском пространстве.

Пользовательские потоки не должны осуществлять специальные неблокирующие системные вызовы.

Когда поток блокируется на системном вызове или на ошибке обращения к отсутствующей странице, должна оставаться возможность выполнения другого потока в рамках того же процесса.

Эффективность достигается путем уклонения от ненуных переходов между пространствами пользователя и ядра.

## Всплывающие потоки

Потоки часто используются в распределённых системах.

Как пример: email.

При поступлении сообщения система создаёт новый поток для его обработки, называется всплывающий поток.

Основное преимущество всплывающих потоков заключается в том, что они создаются заново и не имеют прошлого – никаких регистров, стека и всего остального, что должно быть восстановлено. Каждый такой поток начинается с чистого листа, и каждый из них идентичен всем остальным.

## Состояние состязания

В некоторых операционных системах процессы, работающие совместно, могут сообща использовать некое общее хранилище данных. Каждый из процессов может считывать из общего хранилища данных и записывать туда информацию. Это хранилище представляет собой участок в основной памяти или файл общего доступа.

Если процессу требуется вывести на печать файл, он помещает имя файла в спец. Каталог спулера. Другой процесс, демон печати, проверяет наличие файлов, которые нужно печатать, печатает файл и удаляет его имя из каталога.

## Критические области. Состязания между процессами.

Основной способ предотвращения любой ситуации, связанной с совместным исп. памяти, файлов и чего-либо ещё, является запрет одновременной записи и чтения разделённых данных более чем 1 процессом.

Взаимн.исключение: один процесс использует разделенные данные, другому процессу это будет делать будет запрещено.

Формулировка состояния состязания:
1. Некоторый промежуток времени процесс занят внутренними расчетами и другими задачами, не приводящими к состояниям состязания.
2. В другие моменты времени процесс обращается к совместно используемым данным или выполняет действие, которое может привести к состязанию.
3. Часть программы, в которой есть обращение к совместно используемым данным, называется крит.областью или крит.секцией.
4. Если удастся избежать одновременного нахождения двух процессоров в крит.областях, можно избежать состязаний.

## Крит.области

Для правильной совместной работы параллельных процессов и эффективного использования общих данных необходимо выполнение четырёх условий:
1. Два процесса не должны одновременно находиться в крит.областях.
2. В программе не должно быть предположений о скорости или кол-ве процессоров.
3. Процесс, находящийся вне критической области, не может блокировать другие процессы.
4. Невозможна ситуация, в которой процесс вечно ждёт попадания в крит.область.

# Планирование в системах пакетной обработки заданий

## Первым пришел – первым ушел (FIFO)

- Алгоритм без переключений «первым пришел – первым обслужен» является, пожалуй, самым простым из алгоритмов планирования. Процессам предоставляется доступ к процессору в том порядке, в котором они его запрашивают. Чаще всего формируется единая очередь ждущих процессов. Как только появляется первая задача, она немедленно запускается и работает столько, сколько необходимо.
    
- Остальные задачи ставятся в конец очереди. Когда текущий процесс блокируется, запускается следующий в очереди, а когда блокировка снимается, процесс попадает в конец очереди. Основным преимуществом этого алгоритма является то, что его легко понять и столь же легко программировать. Он справедлив в том же самом смысле, в каком справедливо распределение дефицитных билетов на концерт или соревнования среди всех желающих стоять в очереди с двух часов ночи. В этом алгоритме все процессы в состоянии готовности контролируются одним связным списком. Чтобы выбрать процесс для запуска, нужно всего лишь взять первый элемент списка и удалить его. Появление нового процесса приводит к помещению его в конец списка – что может быть проще?

## «Кратчайшая задача – первая»

- Рассмотрим еще один алгоритм без переключений для систем пакетной обработки, предполагающий, что временные отрезки работы известны заранее.
    
- Например, работники страховой компании могут довольно точно предсказать, сколько времени займет обработка Пакета из 1000 исков, поскольку они делают это каждый день. Если в очереди есть несколько одинаково важных задач, планировщик выбирает первой самую короткую задачу.

## Наименьшее оставшееся время выполнения

- Версией предыдущего алгоритма с переключениями является алгоритм наименьшего оставшегося времени выполнения.
    
- В соответствии с этим алгоритмом планировщик каждый раз выбирает процесс с наименьшим оставшимся временем выполнения.
    
- В этом случае также необходимо заранее знать время выполнения задач.
    
- Когда поступает новая задача, ее полное время выполнения сравнивается с оставшимся временем выполнения текущей задачи.
    
- Если время выполнения новой задачи меньше, текущий процесс приостанавливается и управление передается новой задаче.
    
- Эта схема позволяет быстро обслуживать короткие запросы.

## Трехуровневое планирование

- Системы пакетной обработки позволяют реализовать трехуровневое планирование. По мере поступления в систему новые задачи сна­чала помещаются в очередь, хранящуюся на диске.
    
- Впускной планировщик выбирает задание и передает его системе. Остальные задания остаются в очереди. Характерный алгоритм входного контроля может заключаться в выборе смеси из процессов, ограниченных возможностями процессора, и процессов, ограниченных возможностями устройств ввода-вывода.
    
- Также возможен алгоритм, в котором устанавливается приоритет коротких задач перед длинными.
    
- Впускной планировщик волен придержать некоторые задания во входной очереди, а пропустить задание, поступившее позже остальных.

## Циклическое планирование

- Одним из наиболее старых, простых, справедливых и часто используемых является алгоритм циклического планирования. Каждому процессу предоставля­ется некоторый интервал времени процессора, так называемый квант времени.
    
- Если к концу кванта времени процесс все еще работает, он прерывается, а управление передается другому процессу. Разумеется, если процесс блокируется или прекращает работу раньше, переход управления происходит в этот момент. Реа­лизация циклического планирования проста. Планировщику нужно всего лишь поддерживать список процессов в состоянии готовности. Когда процесс исчерпал свой лимит времени, он отправляется в конец списка.

## Приоритетное планирование

- Необходимость принимать во внимание подобные внешние факторы приводит к приоритетному планированию. Основная идея проста: каждому процессу присваивается приоритет, и управление передается готовому к работе процессу с самым высоким приоритетом.
    
- Даже на персональном компьютере с одним пользователем может происходить несколько процессов, отдельные из которых являются более важными, чем другие. Демон, отвечающий за пересылку электронной почты в фоновом режиме, имеет более низкий приоритет, чем процесс, отображающий на экране видеофильм в реальном времени.
    
- Приоритеты процессам могут присваиваться статически или динамически.

## Несколько очередей

- Один из первых приоритетных планировщиков был реализован в системе CTSS (compatible time-shared system - совместимая система с разделением времени).
    
- В результате было разработано решение с классами приоритетов. Процессам клас­са с высшим приоритетом выделялся один квант, процессам следующего класса - два кванта, следующего - четыре кванта и т. д. Когда процесс использовал все от­веденное ему время, он перемещался на класс ниже. В качестве примера рассмотрим процесс, которому необходимо производить вычисления в течение 100 квантов. Вначале ему будет предоставлен один квант, затем он будет перекачан на диск. В следующий раз ему достанется 2 кванта, за­тем 4, 8,16, 32, 64, хотя из 64 он использует только 37.

## “Самый короткий процесс - следующий”

- Поскольку алгоритм «Кратчайшая задача - первая» минимизирует среднее оборот­ное время в системах пакетной обработки, хотелось бы использовать его и в инте­рактивных системах. Интерактивные процес­сы чаще всего следуют схеме «ожидание команды, исполнение команды, ожида­ние команды, исполнение команды...» Если рассматривать выполнение каждой команды как отдельную задачу, можно минимизировать общее среднее время от­клика, запуская первой самую короткую задачу.
    
- Один из методов основывается на оценке длины процесса, базирующейся на предыдущем поведении процесса. При этом запускается процесс, у которого оце­ненное время самое маленькое. Допустим, что предполагаемое время исполнения команды равно Т0 и предполагаемое время следующего запуска равно Т1. Можно улучшить оценку времени, взяв взвешенную сумму этих времен аТ0 + (1 - а)Т1.
    
- Метод оценки следующего значения серии через взвешенное среднее предыдущего значения и предыдущей оценки часто называют старением.

## Гарантированное планирование

- Принципиально другим подходом к планированию является предоставление пользователям реальных обещаний и затем их выполнение. Вот одно обещание, которое легко произнести и легко выполнить: если вместе с вами процессором пользуются n пользователей, вам будет предоставлено 1 / n мощности процессора.
    
- И в системе с одним пользователем и n запущенными процессорами каждому достанется 1 / n циклов процессора. Чтобы выполнить это обещание, система должна отслеживать распределение процессора между процессами с момента создания каждого процесса. Затем система рассчитывает количество ресурсов процессора, на которое процесс имеет право, например, время с момента создания, деленное на n. Теперь можно сосчитать отношение времени, предоставленного процессу, к времени, на которое он имеет право. Полученное значение 0.5 означает, что процессу выделили только полови­ну положенного, а 2.0 означает, что процессу досталось в два раза больше, чем положено. Затем запускается процесс, у которого это отношение наименьшее, пока оно не станет больше, чем у его ближайшего соседа.

## Лотерейное планирование

- Хотя идея обещаний пользователям и их выполнения хороша, но ее трудно реализовать. Для более простой реализации предсказуемых результатов используется другой алгоритм, называемый лотерейным планированием.
    
- В основе алгоритма лежит раздача процессам лотерейных билетов на доступ к различным ресурсам, в том числе и к процессору. Когда планировщику необходимо принять решение, выбирается случайным образом лотерейный билет, и его обладатель получает доступ к ресурсу. Что касается доступа к процессору, «лотерея» может происходить 50 раз в секунду, и победитель получает 20 мс времени процессора.

# Взаимное исключение с активным ожиданием
**Способы реализации**

## Запрещение прерываний

- Запрет всех прерываний при входе процесса в критическую область и разрешение прерываний по выходе из области.
    
- Если прерывания запрещены, невозможно прерывание по таймеру. Поскольку процессор переключается с одного процесса на другой только по прерыванию, отключение прерываний исключает передачу процессора другому процессу.

## Переменные блокировки

Рассмотрим одну совместно используемую переменную блокировки, изначально равную 0.

- Если процесс хочет попасть в критическую область, он предварительно считывает значение переменной блокировки.
    
- Если переменная равна 0, процесс изменяет ее на 1 и входит в критическую область.
    
- Если же переменная равна 1, то процесс ждет, пока ее значение сменится на 0.

## Переменные блокировки (недостатки)

- Один процесс считывает переменную блокировки, обнаруживает, что она равна 0, но прежде, чем он успевает изменить ее на 1, управление получает другой процесс, успешно изменяющий ее на 1.
    
- Когда первый процесс снова получит управление, он тоже заменит переменную блокировки на 1 и два процесса одновременно окажутся в критических областях.  

## Строгое чередование

- Переменная turn=0 отслеживает, чья очередь входить в критическую область.
    

1. Вначале процесс 0 проверяет значение turn, считывает 0 и входит в критическую область.
    
2. Процесс 1 также проверяет значение turn, считывает 0 и после этого входит в цикл, непрерывно проверяя, когда же значение turn будет равно 1.
    

- Постоянная проверка значения переменной в ожидании некоторого значения называется активным ожиданием. Активное ожидание используется только в случае, когда есть уверенность в небольшом времени ожидания.
    
- Блокировка, использующая активное ожидание, называется спин-блокировкой.

## Команда TSL

Рассмотрим решение, требующее участие аппаратного обеспечения. Многие компьютеры, особенно разработанные с расчетом на несколько процессоров, имеют команду `TSL RX.LOCK` (Test and Set Lock) – проверить и заблокировать), которая действует следующим образом:
В регистр RX считывается содержимое слова памяти lock, а в ячейке памяти lock сохраняется некоторое ненулевое значение. Гарантируется, что операция считывания слова и сохранения неделима – другой процесс не может обратиться к слову в памяти, пока команда не выполнена.

## Примитивы межпроцессного взаимодействия

- Оба решения – Петерсона и с использованием команды TSL – корректны, но они обладают одним и тем же недостатком: использованием активного ожидания.
    
- В сущности, оба они реализуют следующий алгоритм: перед входом в критическую область процесс проверяет, можно ли это сделать. Если нельзя, процесс входит в тугой цикл, ожидая возможности войти в критическую область.

## Примитивы межпроцессного взаимодействия. Пример.

- Этот алгоритм не только бесцельно расходует время процессора, но, кроме этого, он может иметь некоторые неожиданные последствия.
    
- Рассмотрим два процесса: H, с высоким приоритетом и L, с низким приоритетом. Правила планирования в этом случае таковы, что процесс H запускается немедленно, как только он оказывается в состоянии ожидания. В какой-то момент, когда процесс L находится в критической области, процесс H оказывается в состоянии ожидания. Процесс H попадает в состояние активного ожидания, но поскольку процессу L во время работающего процесса H никогда не будет предоставлено процессорное время, у процесса L не будет возможности выйти из критической области, и процесс H навсегда останется в цикле. Эту ситуацию иногда называют проблемой инверсии приоритета.  

## Примитивы межпроцессного взаимодействия

- Теперь рассмотрим некоторые примитивы межпроцессного взаимодействия, применяющиеся вместо циклов ожидания, в которых лишь напрасно расходуется процессорное время. Эти примитивы блокируют процессы в случае запрета на вход в критическую область. Одной из простейших является пара примитивов sleep и wakeup.
    
- Примитив sleep – системный запрос, в результате которого вызывающий процесс блокируется, пока его не запустит другой процесс.
    
- Примитив wakeup есть один параметр – процесс, который следует запустить. Также возможно наличие одного параметра у обоих запросов – адреса ячейки памяти, используемой для согласования запросов ожидания и запуска.

## Семафоры. Операции: down и up.

- Операция down сравнивает значение семафора с нулем.
    
- Если значение семафора больше нуля, операция down уменьшает его и просто возвращает управление. Если значение семафора равно нулю, процедура down не возвращает управление процессу, а процесс переводится в состояние ожидания.
    
- Все операции проверки значения семафора, его изменения и перевода процесса в состояние ожидания выполняются как единое и неделимое элементарное действие. Тем самым гарантируется, что после начала операции ни один процесс не получит доступа к семафору до окончания или блокирования операции.  

## Мьютексы

- Иногда используется упрощенная версия семафора, называемая мьютексом (mutex, сокращение от mutual exclusion – взаимное исключение).
    
- Мьютекс не способен считать, он может лишь управлять взаимным исключением доступа к совместно используемым ресурсам или кодам.
    
- Реализация мьютекса проста и эффективна, что делает использование мьютексов особенно полезным в случае потоков, действующих только в пространстве пользователя.
    
- Мьютекс – переменная, которая может находиться в одном из двух состояний: блокированном или неблокированном.
    
- Для описания мьютекса требуется всего один бит, хотя чаще используется целая переменная, у которой 0 означает неблокированное состояние, а все остальные значения соответствуют блокированному состоянию.
    
- Значение мьютекса устанавливается двумя процедурами. Если поток собирается войти в критическую область, он вызывает процедуру mutex_lock. Если мьютекс не заблокирован, запрос выполняется и вызывающий поток может попасть в критическую область.

## Мониторы 

- В 1974 году Хоар (Hoare) и Бринч Хансен (Brinch Hansen) предложили примитив синхронизации более высокого уровня, называемый монитором.

- Монитор - набор процедур, переменных и других структур данных, объединенных в особый модуль или пакет. Процессы могут вызывать процедуры монитора, но у процедур, объявленных вне монитора, нет прямого доступа к внутренним структурам данных монитора.

## Передача сообщений

Этот метод межпроцессного взаимодействия использует два примитива: send и receive, которые скорее являются системными вызовами, чем структурными компонентами языка. Например:

`send(destination, Smessage);`
`receive(source, &message);`

Первый запрос посылает сообщение заданному адресату, а второй получает сообщение от указанного источника. Если сообщения нет, второй запрос блокируется до поступления сообщения либо немедленно возвращает код ошибки.

## Барьеры

Последний из рассмотренных нами механизмов синхронизации предназначался скорее для групп процессов, нежели для ситуаций с двумя процессами. Некоторые приложения делятся на фазы, и существует правило, что процесс не может перейти в следующую фазу, пока к этому не готовы все остальные процессы. Этого можно добиться, разместив в конце каждой фазы барьер.

## Поведение процесса 

Практически все процессы чередуют периоды вычислений с операциями ввода-вывода. Обычно процессор некоторое время работает без остановки, затем происходит системный вызов на чтение из файла или запись в файл. После выполнения системного вызова процессор опять считает

## Когда планировать ?

Ключевым вопросом планирования является выбор момента принятия решений. Оказывается, существует множество ситуаций, в которых необходимо планирование.

Во-первых, когда создается новый процесс, необходимо решить, какой процесс запустить: родительский или дочерний.

Во-вторых, планирование необходимо, когда процесс завершает работу.

В-третьих, когда процесс блокируется на операции ввода-вывода, семафоре, или по какой-либо другой причине, необходимо выбрать и запустить другой процесс.

В-четвертых, необходимость Планирования может возникнуть при появлении прерывания ввода-вывода. Если прерывание пришло от устройства ввода-вывода, закончившего работу, можно запустить процесс, который был блокирован в ожидании этого события. 

## Когда планировать ? (2)

Алгоритмы планирования можно разделить на две категории согласно их поведению после прерываний.

Алгоритмы планирования без переключений, иногда называемого также неприоритетным планированием.

Алгоритмы планирования с переключениями, называемого также приоритетным планированием, выбирают процесс и позволяют ему работать некоторое максимально возможное фиксированное время. 

## Категории алгоритмов планирования

В различных средах требуются различные алгоритмы планирования. Это связано стем, что различные операционные системы и различные приложения ориентированы на разные задачи. Другими словами, то, для чего следует оптимизировать планировщик, различно в разных системах.

Можно выделить три среды:
1. Системы пакетной обработки данных.
2. Интерактивные системы.
3. Системы реального времени.


В системах пакетной обработки нет пользователей, сидящих за терминалами и ожидающих ответа. В таких системах приемлемы алгоритмы без переключений или с переключениями, но с большим временем, отводимым каждому процессу. Такой метод уменьшает количество переключений между процессами и улучшает эффективность.


В интерактивных системах необходимы алгоритмы планирования с переключениями, чтобы предотвратить захват процессора одним процессом. Даже если ни один процесс не захватывает процессор на неопределенно долгий срок намеренно, из-за ошибки в программе один процесс может заблокировать остальные. Для исключения подобных ситуаций используется планирование с переключениями.

В системах с ограничениями реального времени приоритетность, как это ни странно, не всегда обязательна, поскольку процессы знают, что их время ограничено, и быстро выполняют работу, а затем блокируются. Отличие от интерактивных систем в том, что в системах реального времени работают только программы, предназначенные для содействия конкретным приложениям. Интерактивные системы являются универсальными системами.


## Задачи алгоритмов планирования 

Все системы
- Равнодоступность — предоставление каждому процессу справедливой доли времени центрального процессора.
- Принуждение к определенной политике — наблюдение за выполнением установленной политики. 
- Баланс — поддержка загруженности всех составных частей системы.

Пакетные системы
+ Производительность — выполнение максимального количества заданий в час.
* Оборотное время — минимизация времени между представлением задачи и ее завершением.
- Использование центрального процессора — поддержка постоянной загруженности
процессора.

Интерактивные системы
- Время отклика — быстрый ответ на запросы.
- Пропорциональность — оправдание пользовательских надежд.

Системы реального времени
- Соблюдение предельных сроков — предотвращение потери данных.
- Предсказуемость — предотвращение ухудшения качества в мультимедийных системах.

# Планирование в системах пакетной обработки заданий «Первым пришел — первым ушел (FIFO)»


## «Первым пришел — первым ушел (FIFO)»

Алгоритм без переключений «первым пришел - первым обслужен» является, пожалуй, самым простым из алгоритмов планирования. Процессам предоставляется доступ к процессору в том порядке, в котором они его запрашивают. Чаще всего формируется единая очередь ждущих процессов. Как только появляется первая задача, она немедленно запускается и работает столько, сколько необходимо.

Остальные задачи ставятся в конец очереди. Когда текущий процесс блокируется, запускается следующий в очереди, а когда блокировка снимается, процесс попадает в конец очереди. Основным преимуществом этого алгоритма является то, что его легко понять и столь же легко программировать. Он справедлив в том же самом смысле, в каком справедливо распределение дефицитных билетов на концерт или соревнования среди всех желающих стоять в очереди с двух часов ночи. В этом алгоритме все процессы в состоянии готовности контролируются одним связным списком. Чтобы выбрать процесс для запуска, нужно всего лишь взять первый элемент списка и удалить его. Появление нового процесса приводит к помещению его в конец списка - что может быть проще?


## «Кратчайшая задача - первая»

Рассмотрим еще один алгоритм без переключений для систем пакетной обработки, предполагающий, что временные отрезки работы известны заранее.

Например, работники страховой компании могут довольно точно предсказать, сколько времени займет обработка Пакета из 1000 исков, поскольку они делают это каждый день. Если в очереди есть несколько одинаково важных задач, планировщик выбирает первой самую короткую задачу.

Есть четыре задачи: А, В, С и D, со временем выполнения 8, 4, 4 и 4 мин соответственно.

## Наименьшее оставшееся время выполнения

Версией предыдущего алгоритма с переключениями является алгоритм наименьшего оставшегося времени выполнения.

В соответствии с этим алгоритмом планировщик каждый раз выбирает процесс с наименьшим оставшимся временем выполнения.

В этом случае также необходимо заранее знать время выполнения задач.

Когда поступает новая задача, ее полное время выполнения сравнивается с оставшимся временем выполнения текущей задачи.

Если время выполнения новой задачи меньше, текущий процесс приостанавливается и управление передается новой задаче.

Эта схема позволяет быстро обслуживать короткие запросы.

## Трехуровневое планирование

Системы пакетной обработки позволяют реализовать трехуровневое планирование. По мере поступления в систему новые задачи сначала помещаются в очередь, хранящуюся на диске.

Впускной планировщик выбирает задание и передает его системе. Остальные задания остаются в очереди. Характерный алгоритм входного контроля может заключаться в выборе смеси из процессов, ограниченных возможностями процессора, и процессов, ограниченных возможностями устройств ввода-вывода.

Также возможен алгоритм, в котором устанавливается приоритет коротких задач перед длинными.

Впускной планировщик волен придержать некоторые задания во входной очереди, а пропустить задание, поступившее позже остальных.


## Циклическое планирование

Одним из наиболее старых, простых, справедливых и часто используемых является алгоритм циклического планирования. Каждому процессу предоставляется некоторый интервал времени процессора, так называемый квант времени.

Если к концу кванта времени процесс все еще работает, он прерывается, а управление передается другому процессу. Разумеется, если процесс блокируется или прекращает работу раньше, переход управления происходит в этот момент. Реализация циклического планирования проста. Планировщику нужно всего лишь поддерживать список процессов в состоянии готовности. Когда процесс исчерпал свой лимит времени, он отправляется в конец списка.


## Приоритетное планирование

Необходимость принимать во внимание подобные внешние факторы приводит к приоритетному планированию. Основная идея проста: каждому процессу присваивается приоритет, и управление передается готовому к работе процессу с самым высоким приоритетом.

Даже на персональном компьютере с одним пользователем может происходить несколько процессов, отдельные из которых являются более важными, чем другие. Демон, отвечающий за пересылку электронной почты в фоновом режиме, имеет более низкий приоритет, чем процесс, отображающий на экране видеофильм в реальном времени.

Приоритеты процессам могут присваиваться статически или динамически.


## Несколько очередей

Один из первых приоритетных планировщиков был реализован в системе CTSS

В результате было разработано решение с классами приоритетов. Процессам класса с высшим приоритетом выделялся один квант, процессам следующего класса - два кванта, следующего - четыре кванта и т. д. Когда процесс использовал все отведенное ему время, он перемещался на класс ниже. В качестве примера рассмотрим процесс, которому необходимо производить вычисления в течение 100 квантов. Вначале ему будет предоставлен один квант, затем он будет перекачан на диск. В следующий раз ему достанется 2 кванта, затем 4, 8,16, 32, 64, хотя из 64 он использует только 37.

## Самый короткий процесс — следующий»

Поскольку алгоритм «Кратчайшая задача — первая» минимизирует среднее оборотное время в системах пакетной обработки, хотелось бы использовать его и в интерактивных системах. Интерактивные процессы чаще всего следуют схеме «ожидание команды, исполнение команды, ожидание команды, исполнение команды...» Если рассматривать выполнение каждой команды как отдельную задачу, можно минимизировать общее среднее время отклика, запуская первой самую короткую задачу.

Один из методов основывается на оценке длины процесса, базирующейся на предыдущем поведении процесса. При этом запускается процесс, у которого оцененное время самое маленькое. Допустим, что предполагаемое время исполнения команды равно Т0 и предполагаемое время следующего запуска равно Т1. Можно улучшить оценку времени, взяв взвешенную сумму этих времен аТ0 + (1 - а)Т1.

Метод оценки следующего значения серии через взвешенное среднее предыдущего значения и предыдущей оценки часто называют старением. 

## Гарантированное планирование

Принципиально другим подходом к планированию является предоставление пользователям реальных обещаний и затем их выполнение. Вот одно обещание, которое легко произнести и легко выполнить: если вместе с вами процессором пользуются п пользователей, вам будет предоставлено 1/n мощности процессора.

В системе с одним пользователем и п запущенными процессорами каждому достанется 1/n циклов процессора. Чтобы выполнить это обещание, система должна отслеживать распределение процессора между процессами с момента создания каждого процесса. Затем система рассчитывает количество ресурсов процессора, на которое процесс имеет право, например время с момента создания, деленное на n. Теперь можно сосчитать отношение времени, предоставленного процессу, к времени, на которое он имеет право. Полученное значение 0.5 означает, что процессу выделили только половину положенного, а 2.0 означает, что процессу досталось в два раза больше, чем положено. Затем запускается процесс, у которого это отношение наименьшее, пока оно не станет больше, чем у его ближайшего соседа.

## Лотерейное планирование

Хотя идея обещаний пользователям и их выполнения хороша, но ее трудно реализовать. Для более простой реализации предсказуемых результатов используется другой алгоритм, называемый лотерейным планированием.

В основе алгоритма лежит раздача процессам лотерейных билетов на доступ к различным ресурсам, в том числе и к процессору. Когда планировщику необходимо принять решение, выбирается случайным образом лотерейный билет, и его обладатель получает доступ к ресурсу. Что касается доступа к процессору, «лотерея» может происходить 50 раз в секунду, и победитель получает 20 мс времени процессора.

## Планирование в системах реального времени

Системы реального времени делятся на жесткие системы реального времени, что означает наличие жестких сроков для каждой задачи (в них обязательно надо укладываться), и гибкие системы реального времени, в которых нарушения временного графика нежелательны, но допустимы. В обоих случаях реализуется разделение программы на несколько процессов, каждый из которых предсказуем. Эти процессы чаще всего бывают короткими и завершают свою работу в течение секунды. Когда появляется внешний сигнал, именно планировщик должен обеспечить соблюдение графика.

## Планирование в системах реального времени (2)

Внешние события, на которые система должна реагировать, можно разделить на:
-  периодические (возникающие через регулярные интервалы
времени);
* непериодические (возникающие непредсказуемо).

Возможно наличие нескольких периодических потоков событий, которые система должна обрабатывать. В зависимости от времени, затрачиваемого на обработку каждого из событий, может оказаться, что система не в состоянии своевременно обработать все события.

Если в систему поступает n1 периодических событий, событие с номером i поступает с периодом Pi на его обработку уходит Сi, секунд работы процессора, все потоки могут быть своевременно обработаны только при выполнении условия

## Угрозы безопасности

Объект ОС может подвергнуться следующим типичным атакам:
- сканированию файловой системы
- подбору пароля
- краже ключевой информации
- сборке мусора
- превышению полномочий
- программным закладкам
- жадным программам

## Сканирование файловой системы

Злоумышленник просматривает файловую систему компьютера и пытается прочесть (или скопировать) все файлы подряд. Рано или поздно обнаруживается хотя бы одна ошибка администратора. В результате злоумышленник получает доступ к информации, который должен быть ему запрещен.

## Подбор пароля

Существуют несколько методов подбора паролей пользователей:
1. тотальный перебор;
2. тотальный перебор, оптимизированный по статистике встречаемости символов или с помощью словарей;
3. подбор пароля с использованием знаний о пользователе (его имени, фамилии, даты рождения, номера телефона ит. д.).

## Кража ключевой информации

Злоумышленник может подсмотреть пароль, набираемый пользователем, или восстановить набираемый пользователем пароль по движениям его рук на клавиатуре. Носитель с ключевой информацией (смарт-карта, Touch Memory и т.д.) может быть просто украден.

## Сборка мусора

Во многих ОС информация, уничтоженная пользователем, не уничтожается физически, а помечается как уничтоженная (так называемый мусор). Злоумышленник восстанавливает эту информацию, просматривает ее и копирует интересующие его фрагменты.

## Превышение полномочий

Злоумышленник, используя ошибки в программном обеспечении ОС или политике безопасности, получает полномочия, превышающие те, которые ему предоставлены в соответствии с политикой безопасности. Обычно это достигается путем запуска программы от имени другого пользователя.

## Жадные программы

Жадные программы — это программы, преднамеренно захватывающие
значительную часть ресурсов компьютера, в результате чего другие программы не могут выполняться или выполняются крайне медленно. Запуск жадной программы может привести к краху ОС.



